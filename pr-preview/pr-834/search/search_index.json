{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dataclasses Avro Schema Generator","text":"<p>Generate Avro Schemas from a Python class</p> <p> </p>"},{"location":"#requirements","title":"Requirements","text":"<p><code>python 3.9+</code></p>"},{"location":"#installation","title":"Installation","text":"<p>with <code>pip</code> or <code>poetry</code>:</p> <p><code>pip install dataclasses-avroschema</code> or <code>poetry add dataclasses-avroschema</code></p>"},{"location":"#extras","title":"Extras","text":"<ul> <li>pydantic: <code>pip install 'dataclasses-avroschema[pydantic]'</code> or <code>poetry add dataclasses-avroschema --extras \"pydantic\"</code></li> <li>faust-streaming: <code>pip install 'dataclasses-avroschema[faust]'</code> or <code>poetry add dataclasses-avroschema --extras \"faust \"</code></li> <li>faker: <code>pip install 'dataclasses-avroschema[faker]'</code> or <code>poetry add dataclasses-avroschema --extras \"faker\"</code></li> <li>dc-avro: <code>pip install 'dataclasses-avroschema[cli]'</code> or <code>poetry add dataclasses-avroschema --with cli</code></li> </ul> <p>Note: You can install all extra dependencies with <code>pip install dataclasses-avroschema[faust,pydantic,faker,cli]</code> or <code>poetry add dataclasses-avroschema --extras \"pydantic faust faker cli\"</code></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#generating-the-avro-schema","title":"Generating the avro schema","text":"python &lt;= 3.10python &gt;= 3.11 Trival Usage<pre><code>import enum\nimport typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_color: FavoriteColor\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\nUser.avro_schema()\n\n'{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": \"array\", \"items\": \"string\"},\n        {\"name\": \"accounts\", \"type\": \"map\", \"values\": \"long\"},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"Blue\", \"Yellow\", \"Green\"]}}\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\nUser.avro_schema_to_python()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": None}\n    ],\n}\n</code></pre> Trival Usage<pre><code>import enum\nimport typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_color: FavoriteColor\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\nUser.avro_schema()\n\n'{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": \"array\", \"items\": \"string\"},\n        {\"name\": \"accounts\", \"type\": \"map\", \"values\": \"long\"},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"Blue\", \"Yellow\", \"Green\"]}}\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\nUser.avro_schema_to_python()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": None}\n    ],\n}\n</code></pre>"},{"location":"avro_schema/","title":"Avro Schema and Python Classes","text":""},{"location":"avro_schema/#avro-schemas-and-python-class","title":"Avro Schemas and Python Class","text":""},{"location":"avro_schema/#what-is-apache-avro","title":"What is Apache Avro?","text":"<p>Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a <code>schema</code> to structure the data that is being encoded. It has two different types of schema languages; one for human editing <code>(Avro IDL)</code> and another which is more machine-readable based on <code>(JSON)</code></p>"},{"location":"avro_schema/#goal","title":"Goal","text":"<p>Our goal is to come up with an <code>avro schema</code> from <code>Python classes</code>. We can think a <code>avro Record</code> as an analogous to a <code>python class</code>, but first, let's explaine what a <code>record</code> is.</p>"},{"location":"avro_schema/#records","title":"Records","text":"<p>Records are one of the <code>Complex Types</code> in avro. It use the type name <code>record</code> and support three attributes.</p> <ul> <li>name: a JSON string providing the name of the record (required).</li> <li>namespace: a JSON string that qualifies the name;</li> <li>doc: a JSON string providing documentation to the user of this schema (optional).</li> <li>aliases: a JSON array of strings, providing alternate names for this record (optional).</li> <li>fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes:<ul> <li>name: a JSON string providing the name of the field (required), and</li> <li>doc: a JSON string describing this field for users (optional).</li> <li>type: A JSON object defining a schema, or a JSON string naming a record definition (required).</li> <li>default: A default value for this field, used when reading instances that lack this field (optional). Permitted    values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255.</li> <li>order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below.</li> <li>aliases: a JSON array of strings, providing alternate names for this field (optional).</li> </ul> </li> </ul> <p>For example, a User may be defined with:</p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\" : [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"int\"},\n        {\"name\": \"has_pets\", \"type\": \"boolean\"},\n        {\"name\": \"money\", \"type\": \"float\"}\n    ]\n}\n</code></pre>"},{"location":"avro_schema/#from-a-python-class-to-the-avro-schema","title":"From a Python class to the Avro Schema","text":"<p>Image that you have to define the previous <code>User</code> schema but you do not know avro, you know python:</p> Generate the avro schema from a class<pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    has_pets: bool\n    money: float\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\"},\n    {\"name\": \"money\", \"type\": \"float\"}\n  ],\n  \"doc\": \"User(name: str, age: int, has_pets: bool, money: float)\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>or create a python dictionary</p> Avro schema to python<pre><code>User.avro_schema_to_python()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"favorite_color\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": None}\n    ],\n}\n</code></pre> <p>and that is it!! Each python field is related with a avro type. You can find the field relationships here:</p>"},{"location":"case/","title":"Case schemas","text":"<p>Sometimes we use <code>avro schemas</code> with different sources (some written in Scala, some in Python, etc). With the <code>case</code> you can generate your schemas according to your programming language convention:</p> python &lt;= 3.10python &gt;= 3.11 Example with CAPITALCASE<pre><code>import typing\nimport dataclasses\nimport enum\n\nfrom dataclasses_avroschema import AvroModel, case, types\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: FavoriteColor\n    has_car: bool = False\n    country: str = \"Argentina\"\n    address: str = None\n    md5: types.Fixed = types.Fixed(16)\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema(case_type=case.CAPITALCASE)\n</code></pre> <p>resulting in</p> <pre><code>{\n    \"type\": \"record\", \n    \"name\": \"UserAdvance\", \n    \"fields\": [\n        {\"name\": \"Name\", \"type\": \"string\"},\n        {\"name\": \"Age\", \"type\": \"long\"},\n        {\"name\": \"Pets\", \"type\": {\n            \"type\": \"array\", \"items\": \"string\", \"name\": \"Pet\"\n            }\n        },\n        {\"name\": \"Accounts\", \"type\": {\n            \"type\": \"map\", \"values\": \"long\", \"name\": \"Account\"\n            }\n        },\n        {\"name\": \"Has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"Favorite_colors\", \"type\": {\n            \"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]\n            }\n        },\n        {\"name\": \"Country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"Address\", \"type\": [\"null\", \"string\"], \"default\": null},\n        {\"name\": \"Md5\", \"type\": {\"type\": \"fixed\", \"name\": \"Md5\", \"size\": 16}}\n    ]\n}'\n</code></pre> Example with CAPITALCASE<pre><code>import typing\nimport dataclasses\nimport enum\n\nfrom dataclasses_avroschema import AvroModel, case, types\n\n\n# New enum!!\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: FavoriteColor\n    has_car: bool = False\n    country: str = \"Argentina\"\n    address: str = None\n    md5: types.Fixed = types.Fixed(16)\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema(case_type=case.CAPITALCASE)\n</code></pre> <p>resulting in</p> <pre><code>{\n    \"type\": \"record\", \n    \"name\": \"UserAdvance\", \n    \"fields\": [\n        {\"name\": \"Name\", \"type\": \"string\"},\n        {\"name\": \"Age\", \"type\": \"long\"},\n        {\"name\": \"Pets\", \"type\": {\n            \"type\": \"array\", \"items\": \"string\", \"name\": \"Pet\"\n            }\n        },\n        {\"name\": \"Accounts\", \"type\": {\n            \"type\": \"map\", \"values\": \"long\", \"name\": \"Account\"\n            }\n        },\n        {\"name\": \"Has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"Favorite_colors\", \"type\": {\n            \"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]\n            }\n        },\n        {\"name\": \"Country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"Address\", \"type\": [\"null\", \"string\"], \"default\": null},\n        {\"name\": \"Md5\", \"type\": {\"type\": \"fixed\", \"name\": \"Md5\", \"size\": 16}}\n    ]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>Cases do not apply to <code>records</code> and <code>enums</code> names as they are always expressed in <code>PascalCase</code></p>"},{"location":"case/#available-cases","title":"Available cases","text":"Case Example camelcase 'foo_bar_baz' # =&gt; \"fooBarBaz\" capitalcase 'foo_bar_baz' # =&gt; \"Foo_bar_baz\" constcase 'FooBarBaz' # =&gt; \"_FOO_BAR_BAZ\" lowercase 'FooBarBaz' # =&gt; \"foobarbaz\" pascalcase 'FooBarBaz' # =&gt; \"FooBarBaz\" pathcase 'foo_bar_baz' # =&gt; \"foo/bar/baz\" snakecase 'FooBarBaz' # =&gt; \"foo_bar_baz\" upperspinalcase 'FooBarBaz' # =&gt; \"-foo-bar-baz\" spinalcase 'FooBarBaz' # =&gt; \"FOO-BAR\" trimcase 'FooBarBaz' # =&gt; \"FooBarBaz\" uppercase 'FooBarBaz' # =&gt; \"FOOBARBAZ alphanumcase 'Foo_123 Bar!' # =&gt;'Foo123Bar'"},{"location":"complex_types/","title":"Complex Types","text":"<p>The following list represent the avro complex types mapped to python types:</p> python &lt;= 3.10python &gt;= 3.11 Avro Type Python Type enums enum.Enum, typing.Literal[str] arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.confixed unions typing.Union unions with <code>null</code> typing.Optional records Python Class Avro Type Python Type enums str, enum.Enum, typing.Literal[str] arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.confixed unions typing.Union unions with <code>null</code> typing.Optional records Python Class"},{"location":"complex_types/#enums","title":"Enums","text":"python &lt;= 3.10python &gt;= 3.11 Enum example<pre><code>import enum\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n    class Meta:\n        doc = \"A favorite color\"\n        namespace = \"some.name.space\"\n        aliases = [\"Color\", \"My favorite color\"]\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    favorite_color: FavoriteColor = FavoriteColor.BLUE\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\":\n  [\n    {\n      \"name\": \"favorite_color\",\n      \"type\":\n      {\n        \"type\": \"enum\",\n        \"name\": \"FavoriteColor\",\n        \"symbols\":\n        [\n          \"Blue\",\n          \"Yellow\",\n          \"Green\"\n        ],\n        \"doc\": \"A favorite color\",\n        \"namespace\": \"some.name.space\",\n        \"aliases\":\n        [\"Color\", \"My favorite color\"]\n      },\n      \"default\": \"Blue\"\n    }\n  ],\n  \"doc\": \"An User\"\n}'\n</code></pre> Enum example<pre><code>import enum\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n    @enum.nonmember\n    class Meta:\n        doc = \"A favorite color\"\n        namespace = \"some.name.space\"\n        aliases = [\"Color\", \"My favorite color\"]\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    favorite_color: FavoriteColor = FavoriteColor.BLUE\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\":\n  [\n    {\n      \"name\": \"favorite_color\",\n      \"type\":\n      {\n        \"type\": \"enum\",\n        \"name\": \"FavoriteColor\",\n        \"symbols\":\n        [\n          \"Blue\",\n          \"Yellow\",\n          \"Green\"\n        ],\n        \"doc\": \"A favorite color\",\n        \"namespace\": \"some.name.space\",\n        \"aliases\":\n        [\"Color\", \"My favorite color\"]\n      },\n      \"default\": \"Blue\"\n    }\n  ],\n  \"doc\": \"An User\"\n}'\n</code></pre> <p>Info</p> <p>There are not restriction about <code>enum</code> names but is is highly recommended to use <code>pascalcase</code></p>"},{"location":"complex_types/#enums-from-typingliteral-of-strigns","title":"Enums from typing.Literal of strigns","text":"<p><code>typing.Literal[...]</code> can be used to indicate to type checkers that the annotated object has a value equivalent to one of the provided literals. If all <code>Literal arguments</code> are <code>string</code>, then for some use cases an <code>avro enum</code> as representation would make more sense in order to preserve the constraints (<code>Literal arguments</code> to <code>enum symbols</code>).</p> <p>For this behaviour the attribute <code>convert_literal_to_enum</code> must be set to <code>True</code></p> Literal as avro enumLiteral as avro string <pre><code>import dataclasses\nimport typing\nfrom dataclasses_avroschema import AvroModel\n\n@dataclasses.dataclass\nclass MyModel(AvroModel):\n    options: typing.Literal[\"four_4\", \"five_5\"] = \"four_4\"\n    optional_field: typing.Optional[typing.Literal[\"four_4\", \"five_5\"]] = None\n\n    class Meta:\n        convert_literal_to_enum = True\n\nprint(MyModel.avro_schema())\n\n{\n  \"type\": \"record\",\n  \"name\": \"MyModel\", \"fields\": [\n    {\"name\": \"options\", \"type\": {\"type\": \"enum\", \"name\": \"options\", \"symbols\": [\"four_4\", \"five_5\"]}, \"default\": \"four_4\"},\n    {\"name\": \"optional_field\", \"type\": [\"null\", {\"type\": \"enum\", \"name\": \"optional_field\", \"symbols\": [\"four_4\", \"five_5\"]}], \"default\": null}]\n}\n</code></pre> <pre><code>import dataclasses\nimport typing\nfrom dataclasses_avroschema import AvroModel\n\n@dataclasses.dataclass\nclass MyModel(AvroModel):\n    options: typing.Literal[\"four_4\", \"five_5\"] = \"four_4\"\n    optional_field: typing.Optional[typing.Literal[\"four_4\", \"five_5\"]] = None\n\nprint(MyModel.avro_schema())\n\n{\n  \"type\": \"record\",\n  \"name\": \"MyModel\",\n  \"fields\": [\n    {\"name\": \"options\", \"type\": \"string\", \"default\": \"four_4\"},\n    {\"name\": \"optional_field\", \"type\": [\"null\", \"string\"], \"default\": null}\n  ]\n}\n</code></pre>"},{"location":"complex_types/#repeated-enums","title":"Repeated Enums","text":"<p>Sometimes we have cases where an <code>Enum</code> is used more than once with a particular class, for those cases the same <code>type</code> is used in order to generate a valid schema. It is a good practice but NOT neccesary to a define the <code>namespace</code> on the repeated <code>type</code>.</p> python &lt;= 3.10python &gt;= 3.11 <pre><code>import enum\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass TripDistance(enum.Enum):\n    CLOSE = \"Close\"\n    FAR = \"Far\"\n\n    class Meta:\n        doc = \"Distance of the trip\"\n        namespace = \"trip\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    trip_distance: TripDistance\n    optional_distance: typing.Optional[TripDistance] = None\n\n\nprint(User.avro_schema())\n</code></pre> <pre><code>import enum\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass TripDistance(str, enum.Enum):\n    CLOSE = \"Close\"\n    FAR = \"Far\"\n\n    @enum.nonmember\n    class Meta:\n        doc = \"Distance of the trip\"\n        namespace = \"trip\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    trip_distance: TripDistance\n    optional_distance: typing.Optional[TripDistance] = None\n\n\nprint(User.avro_schema())\n</code></pre> <p>resulting in</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"trip_distance\",\n      \"type\": {\n        \"type\": \"enum\",\n        \"name\": \"TripDistance\",\n        \"symbols\": [\n          \"Close\",\n          \"Far\"\n        ],\n        \"doc\": \"Distance of the trip\",\n        \"namespace\": \"trip\"\n      }\n    },\n    {\n      \"name\": \"optional_distance\",\n      \"type\": [\n        \"null\",\n        \"trip.TripDistance\"  // using the namespace and the TripDistance type\n      ],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"User(trip_distance: __main__.TripDistance, optional_distance: Optional[__main__.TripDistance] = None)\"\n}\n</code></pre>"},{"location":"complex_types/#enums-type-level-default","title":"Enums type level default","text":"<p>From <code>avro 1.9.0</code> it is possible to set <code>enum type level default</code>: Enum type level default value is to deal with newly added symbols that the reader does not know about. This is for forward compatibility.</p> Example<pre><code>{\n  \"type\": \"record\",\n  \"name\": \"MyRecord\",\n  \"fields\": [\n    {\n      \"name\": \"my_field\",\n      \"type\": {\n        \"type\": \"enum\",\n        \"name\": \"MyEnum\",\n        \"symbols\": [\n          \"A\",\n          \"B\",\n          \"Unknown\"\n        ],\n        /* \n         * Symbol default - for forward compatibility - \n         * new in Avro 1.9.0\n         */\n         \"default\": \"Unknown\"  \n      },\n      /*\n       * Field default - for handle backwards compatibility\n       */ \n      \"default\": \"Unknown\"    \n    }\n  ]\n}\n</code></pre> <p>The question is: how can we set a <code>enum type level default</code>?. The answer is using the <code>class Meta</code></p> python &lt;= 3.10python &gt;= 3.11 <pre><code>import enum\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass MyEnum(enum.Enum):\n    A = \"A\"\n    B = \"B\"\n    UNKNOWN = \"Unknown\"\n\n    class Meta:\n        default = \"Unknown\"\n\n\n@dataclass\nclass MyRecord(AvroModel):\n    my_field: MyEnum = MyEnum.UNKNOWN\n</code></pre> <pre><code>import enum\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass MyEnum(str, enum.Enum):\n    A = \"A\"\n    B = \"B\"\n    UNKNOWN = \"Unknown\"\n\n    @enum.nonmember\n    class Meta:\n        default = \"Unknown\"\n\n\n@dataclass\nclass User(AvroModel):\n    my_field: MyEnum = MyEnum.UNKNOWN\n</code></pre> <p>Warning</p> <p>This is great because we achieve avro <code>FULL COMPATIBILITY</code>, however this can lead to confusing scenarios. Check the discussion for more insight</p>"},{"location":"complex_types/#arrays","title":"Arrays","text":"Array example<pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    \"User advanced\"\n    pets: typing.List[str]\n    cars: typing.List[str] = None\n    favourites_numbers: typing.List[int] = dataclasses.field(default_factory=lambda: [7, 13])\n\n\nUserAdvance.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"pets\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"pet\"\n      }\n    },\n    {\n      \"name\": \"cars\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"car\"\n      },\n      \"default\": []\n    },\n    {\n      \"name\": \"favourites_numbers\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"long\",\n        \"name\": \"favourites_number\"\n      },\n      \"default\": [7, 13]\n    }\n  ],\n  \"doc\": \"User advanced\"\n}'\n</code></pre>"},{"location":"complex_types/#maps","title":"Maps","text":"Map example<pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    \"User advanced\"\n    accounts_money: typing.Dict[str, float]\n    cars_brand_total: typing.Dict[str, int] = None\n    family_ages: typing.Dict[str, int] = dataclasses.field(default_factory=lambda: {\"father\": 50})\n\nUserAdvance.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"accounts_money\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"float\",\n        \"name\": \"accounts_money\"\n      }\n    },\n    {\n      \"name\": \"cars_brand_total\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"cars_brand_total\"\n      },\n      \"default\": {}\n    },\n    {\n      \"name\": \"family_ages\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"family_age\"\n      },\n      \"default\": {\"father\": 50}\n    }\n  ],\n  \"doc\": \"User advanced\"\n}'\n</code></pre>"},{"location":"complex_types/#fixed","title":"Fixed","text":"<p>Fixed types in avro must specify one required attribute size  which specifies the number of bytes per value. Because the <code>fixed</code> type does not exist in python it is not possible to supply the required arguments directly in the type so dataclasses-avroschema provides a funtion to create fixed. The function types.confixed annotates the <code>types.Fixed</code> type and it adds the required attibutes.</p>"},{"location":"complex_types/#arguments-to-confixed","title":"Arguments to confixed","text":"<p>The following arguments are available when using the confixed type function</p> <ul> <li>size (int): number of bytes per value</li> <li>aliases (List[str]):  a List of strings, providing alternate names (optional)</li> <li>namespace (str): a string that qualifies the name (optional);</li> </ul> Fixed example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    md5: types.confixed(size=16, namespace='md5', aliases=[\"md5\", \"hash\"])\n    name: types.confixed(size=16) = b\"u00ffffffffffffx\"\n\nUnionSchema.avro_schema()\n\n{\n  'type': 'record',\n  'name': 'UserAdvance',\n  'fields': [\n    {'name': 'md5', 'type': {'type': 'fixed', 'name': 'md5', 'size': 16,'namespace': 'md5', 'aliases': ['md5', 'hash']}},\n    {\"name\": \"name\", \"type\": {\"type\": \"fixed\", \"name\": \"name\", \"size\": 16}, \"default\": \"u00ffffffffffffx\"}\n  ],\n  'doc': 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)'}\n</code></pre>"},{"location":"complex_types/#unions","title":"Unions","text":"python &lt;= 3.9python3.10 <pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: typing.Union[str, int]\n    logical_union: typing.Union[datetime.datetime, datetime.date, uuid.uuid4]\n    second_union: typing.Union[str, int] = \"test\"\n    third_union: typing.Union[int, str] = 'STRING TYPE'\n\nUnionSchema.avro_schema()\n</code></pre> <pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: str | int\n    logical_union: datetime.datetime | datetime.date | uuid.uuid\n    second_union: str | int = \"test\"\n    third_union: int | str = 'STRING TYPE'\n\nUnionSchema.avro_schema()\n</code></pre> result<pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UnionSchema\",\n  \"fields\": [\n  {\"name\": \"first_union\", \"type\": [\"string\", \"long\"]},\n  {\"name\": \"logical_union\", \"type\": [\n    {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"},\n    {\"type\": \"long\", \"logicalType\": \"date\"},\n    {\"type\": \"string\", \"logicalType\": \"uuid\"}]},\n  {\"name\": \"second_union\", \"type\": [\"string\", \"long\"], \"default\": \"test\"},\n  {\"name\": \"third_union\", \"type\": [\"string\", \"long\"], \"default\": \"STRING TYPE\"}],\n  \"doc\": \"Some Unions\"\n}\n</code></pre>"},{"location":"complex_types/#union-with-records","title":"Union with Records","text":"python &lt;= 3.9python3.10 <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Bus(AvroModel):\n    \"A Bus\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass Car(AvroModel):\n    \"A Car\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n  \"Some Unions\"\n  lake_trip: typing.Union[Bus, Car]\n  river_trip: typing.Union[Bus, Car] = None\n  mountain_trip: typing.Union[Bus, Car] = dataclasses.field(\n      default_factory=lambda: Bus(\"engine_name\": \"honda\"))\n\nUnionSchema.avro_schema()\n</code></pre> <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Bus(AvroModel):\n    \"A Bus\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass Car(AvroModel):\n    \"A Car\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n  \"Some Unions\"\n  lake_trip: Bus | Car\n  river_trip: Bus | Car | None = None\n  mountain_trip: Bus | Car = dataclasses.field(\n      default_factory=lambda: Bus(\"engine_name\": \"honda\"))\n\nUnionSchema.avro_schema()\n</code></pre> result<pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UnionSchema\",\n  \"fields\": [\n    {\n      \"name\": \"lake_trip\",\n      \"type\": [\n        {\n          \"type\": \"record\",\n          \"name\": \"Bus\",\n          \"fields\": [\n            {\n              \"name\": \"engine_name\",\n              \"type\": \"string\"\n            }\n          ],\n          \"doc\": \"A Bus\"\n        },\n        {\n          \"type\": \"record\",\n          \"name\": \"Car\",\n          \"fields\": [\n            {\n              \"name\": \"engine_name\",\n              \"type\": \"string\"\n            }\n          ],\n          \"doc\": \"A Car\"\n        }\n      ]\n    },\n    {\n      \"name\": \"river_trip\",\n      \"type\": [\n        \"null\",\n        \"types.Bus\",\n        \"types.Car\"\n      ]\n      \"default\": null\n    },\n    {\n      \"name\": \"mountain_trip\",\n      \"type\": [\n        \"types.Bus\",\n        \"types.Car\"\n      ],\n      \"default\": {\"engine_name\": \"honda\"}\n    }\n  ],\n  \"doc\": \"Some Unions\"\n}\n</code></pre> <p>Note</p> <p>From python 3.10 you can use union type expressions using the <code>|</code> operator</p>"},{"location":"complex_types/#unions-with-typingoptional","title":"Unions with typing.Optional","text":"<p><code>typing.Optional[Any]</code> is translated as an optional Union: <code>typing.Union[Any, NoneType]</code> where <code>NoneType</code> is always at the end</p> python &lt;= 3.9python3.10 <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses import dataclass, field\n\n\n@dataclasses.dataclass\nclass X(AvroModel):\n    y: typing.Optional[typing.List[int]]\n\n\nX.avro_schema()\n</code></pre> <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses import dataclass, field\n\n\n@dataclasses.dataclass\nclass X(AvroModel):\n    y: typing.List[int] | None\n\n\nX.avro_schema()\n</code></pre> result<pre><code>{\n    \"type\": \"record\",\n    \"name\": \"X\",\n    \"fields\": [\n        {\"name\": \"y\", \"type\": [{\"type\": \"array\", \"items\": \"long\", \"name\": \"y\"}, \"null\"]}\n    ],\n    \"doc\": \"X(y: Union[List[int], NoneType])\"\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Under examples folder you can find 4 differents examples, one with aiokafka (<code>async</code>) showing the simplest use case when a <code>AvroModel</code> instance is serialized and sent it thorught kafka, and the event is consumed. The other two examples are <code>sync</code> using the kafka-python driver, where the <code>avro-json</code> serialization and <code>schema evolution</code> (<code>FULL</code> compatibility) is shown. The last example is a redis example with the python drivers walrus</p>"},{"location":"examples/#kafka-examples","title":"Kafka examples","text":"aiokafka example<pre><code>import asyncio\nimport enum\nimport random\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom aiokafka import AIOKafkaConsumer, AIOKafkaProducer\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\nasync def consume(loop, total_events=10):\n    consumer = AIOKafkaConsumer(\n        \"my_topic\",\n        \"my_other_topic\",\n        loop=loop,\n        bootstrap_servers=\"localhost:9092\",\n        group_id=\"my-group\",\n    )\n    # Get cluster layout and join group `my-group`\n    await consumer.start()\n    run_consumer = True\n\n    while run_consumer:\n        try:\n            # Consume messages\n            async for msg in consumer:\n                print(f\"Message received: {msg.value} at {msg.timestamp}\")\n\n                user = UserModel.deserialize(msg.value)\n                print(f\"Message deserialized: {user}\")\n        except KeyboardInterrupt:\n            # Will leave consumer group; perform autocommit if enabled.\n            await consumer.stop()\n            print(\"Stoping consumer...\")\n            run_consumer = False\n\n\nasync def send(loop, total_events=10):\n    producer = AIOKafkaProducer(loop=loop, bootstrap_servers=\"localhost:9092\")\n    # Get cluster layout and initial topic/partition leadership information\n    await producer.start()\n\n    for event_number in range(1, total_events + 1):\n        # Produce message\n        print(f\"Sending event number {event_number}\")\n\n        user = UserModel(\n            name=random.choice(\n                [\n                    \"Juan\",\n                    \"Peter\",\n                    \"Michael\",\n                    \"Moby\",\n                    \"Kim\",\n                ]\n            ),\n            age=random.randint(1, 50),\n        )\n\n        # create the message\n        message = user.serialize()\n\n        await producer.send_and_wait(\"my_topic\", message)\n        # sleep for 2 seconds\n        await asyncio.sleep(2)\n    else:\n        # Wait for all pending messages to be delivered or expire.\n        await producer.stop()\n        print(\"Stoping producer...\")\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    tasks = asyncio.gather(send(loop), consume(loop))\n    loop.run_until_complete(tasks)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> kafka-python example<pre><code>import enum\nimport random\nfrom dataclasses import dataclass\nfrom time import sleep\nfrom typing import Optional\n\nfrom kafka import KafkaConsumer, KafkaProducer\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\ndef consume():\n    consumer = KafkaConsumer(\n        \"my_topic\", bootstrap_servers=\"localhost:9092\", group_id=\"my-group\"\n    )\n\n    for msg in consumer:\n        print(f\"Message received: {msg.value} at {msg.timestamp}\")\n\n        user = UserModel.deserialize(msg.value)\n        print(f\"Message deserialized: {user}\")\n\n    print(\"Stoping consumer...\")\n\n\ndef send(total_events=10):\n    producer = KafkaProducer(bootstrap_servers=\"localhost:9092\")\n\n    for event_number in range(1, total_events + 1):\n        # Produce message\n        print(f\"Sending event number {event_number}\")\n\n        # create an instance of User v1\n        user = UserModel(\n            name=random.choice(\n                [\n                    \"Juan\",\n                    \"Peter\",\n                    \"Michael\",\n                    \"Moby\",\n                    \"Kim\",\n                ]\n            ),\n            age=random.randint(1, 50),\n        )\n\n        # create the message\n        message = user.serialize()\n\n        producer.send(\"my_topic\", message)\n        # sleep for 2 seconds\n        sleep(1)\n\n    print(\"Stoping producer...\")\n\n\ndef main():\n    send()\n    consume()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> schema evolution example<pre><code>import enum\nimport random\nfrom dataclasses import dataclass\nfrom time import sleep\nfrom typing import Optional\n\nfrom kafka import KafkaConsumer, KafkaProducer\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n    testing: bool = False\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\n@dataclass\nclass UserModelV2(AvroModel):\n    \"A User v2\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n\n    class Meta:\n        namespace = \"User.v2\"\n\n\ndef consume():\n    consumer = KafkaConsumer(\n        \"my_topic\", bootstrap_servers=\"localhost:9092\", group_id=\"my-group\"\n    )\n\n    for msg in consumer:\n        print(f\"Message received: {msg.value} at {msg.timestamp}\")\n\n        # create an instance of User v2\n        user = UserModelV2.deserialize(msg.value)\n        print(f\"Message deserialized: {user}\")\n\n    print(\"Stoping consumer...\")\n\n\ndef send(total_events=2):\n    producer = KafkaProducer(bootstrap_servers=\"localhost:9092\")\n\n    for event_number in range(1, total_events + 1):\n        # Produce message\n        print(f\"Sending event number {event_number}\")\n\n        # create an instance of User v1\n        user = UserModel(\n            name=random.choice(\n                [\n                    \"Juan\",\n                    \"Peter\",\n                    \"Michael\",\n                    \"Moby\",\n                    \"Kim\",\n                ]\n            ),\n            age=random.randint(1, 50),\n        )\n\n        print(user)\n\n        # create the message\n        message = user.serialize()\n\n        producer.send(\"my_topic\", message)\n        # sleep for 2 seconds\n        sleep(1)\n\n    print(\"Stoping producer...\")\n\n\ndef main():\n    send()\n    consume()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"examples/#redis-examples","title":"Redis examples","text":"<p>Minimal redis example using <code>redis streams</code> with walrus driver.</p> redis streams example<pre><code>import enum\nimport random\nfrom dataclasses import dataclass\nfrom time import sleep\nfrom typing import Optional\n\nfrom walrus import Database  # A subclass of the redis-py Redis client.\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n    testing: bool = False\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\ndef consume(consumer_group):\n    # read new messages in the stream\n\n    while True:\n        result = consumer_group.my_stream.read(count=1, block=1000)\n        # Each record has the followinf format\n        # [(b'1598545738231-0', {b'message': b'\\x06KimT\\x00\\x12Argentina\\x00\\x00'})]\n\n        if result:\n            message_id, message_content = result[0]\n\n            if message_id:\n                value = message_content[b\"message\"]\n                print(f\"Processing message {message_id} with value {value}\")\n                user = UserModel.deserialize(value)\n                print(user)\n\n\ndef produce(consumer_group):\n    for i in range(10):\n        # create an instance of User v1\n        user = UserModel(\n            name=random.choice(\n                [\n                    \"Juan\",\n                    \"Peter\",\n                    \"Michael\",\n                    \"Moby\",\n                    \"Kim\",\n                ]\n            ),\n            age=random.randint(1, 50),\n        )\n\n        msgid = consumer_group.my_stream.add({\"message\": user.serialize()})\n        print(f\"Producing message {msgid}\")\n\n    print(\"Producer finished....\")\n    print(\"#\" * 80)\n    sleep(2)\n\n\ndef main():\n    db = Database()\n    stream_name = \"my-stream\"\n    db.Stream(stream_name)  # Create a new stream instance\n\n    # create the consumer group\n    consumer_group = db.consumer_group(\"my-consumer-group-1\", [stream_name])\n    consumer_group.create()  # Create the consumer group.\n    consumer_group.set_id(\"$\")\n\n    produce(consumer_group)\n    consume(consumer_group)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"examples/#rabbitmq-examples","title":"RabbitMQ examples","text":"<p>Minimal rabbitmq example with pika driver.</p> rabbitmq example<pre><code>import enum\nimport random\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nimport pika\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: Optional[str] = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\ndef consume(*, channel, queue_name: str):\n    def callback(channel: str, method, properties, body):\n        print(f\"Message received with body: {body} in channel {method} \\n\")\n        user = UserModel.deserialize(body)\n        print(f\"Message deserialized: {user} \\n\")\n\n    channel.basic_consume(on_message_callback=callback, queue=queue_name)\n    channel.start_consuming()\n\n\ndef produce(*, channel, queue_name: str, total_events: int = 10):\n    for event_number in range(1, total_events + 1):\n        # Produce message\n        print(f\"Sending event number {event_number}\")\n\n        user = UserModel(\n            name=random.choice(\n                [\n                    \"Juan\",\n                    \"Peter\",\n                    \"Michael\",\n                    \"Moby\",\n                    \"Kim\",\n                ]\n            ),\n            age=random.randint(1, 50),\n        )\n\n        # create the message\n        message = user.serialize()\n\n        # publish\n        channel.basic_publish(exchange=\"\", routing_key=queue_name, body=message)\n\n\ndef main():\n    rabbitmq_url = \"amqp://guest:guest@localhost:5672/%2f\"\n    queue_name = \"test-stream\"\n    params = pika.URLParameters(rabbitmq_url)\n\n    connection = pika.BlockingConnection(params)\n    channel = connection.channel()\n    channel.queue_declare(queue=queue_name, durable=True)\n\n    produce(channel=channel, queue_name=queue_name)\n    consume(channel=channel, queue_name=queue_name)\n\n    connection.close()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"factories_and_fixtures/","title":"Factories and Fixtures","text":"<p>Dataclasses Avro Schema also includes a <code>factory</code> feature, so you can generate <code>fast</code> python instances and use them, for example, to test your data streaming pipelines. Instances can be genrated using the <code>fake</code> method.</p> Basic usage<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\n\nAddress.fake()\n# &gt;&gt;&gt;&gt; Address(street='PxZJILDRgbXyhWrrPWxQ', street_number=2067)\n\nUser.fake()\n# &gt;&gt;&gt;&gt; User(name='VGSBbOGfSGjkMDnefHIZ', age=8974, addresses=[Address(street='vNpPYgesiHUwwzGcmMiS', street_number=4790)])\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"factories_and_fixtures/#pydantic-fixtures","title":"Pydantic fixtures","text":"<p>It is also possible to generate fixtures with the <code>pydantic integration</code> simply using <code>AvroBaseModel</code>:</p> <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass Address(AvroBaseModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    address: typing.Optional[Address] = None\n\n\nAddress.fake()\n# &gt;&gt;&gt;&gt; Address(street='PxZJILDRgbXyhWrrPWxQ', street_number=2067)\n\nUser.fake()\n# &gt;&gt;&gt;&gt; User(name='MCyzAtufQSwjxwCOmIBV', age=4377, address=Address(street='fUQfMHpvxsfmBDcaWJxb', street_number=722))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"factories_and_fixtures/#providing-data-to-the-factory","title":"Providing data to the factory","text":"<p>It is also possible to provide data as <code>keyword arguments</code> to the factory using the <code>fake</code> method.</p> <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    has_car: bool = False\n    country: str = \"Argentina\"\n    address: typing.Optional[str] = None\n\n\nuser = UserAdvance.fake(name=\"bond\", age=50, pets=[\"dog\", \"cat\"])\nassert user.name == \"bond\"\nassert user.age == 50\nassert user.pets == [\"dog\", \"cat\"]\n\nprint(user)\n# &gt;&gt;&gt;&gt; UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'uVITaqdTStKhsdHFqIdM': 4201}, has_car=True, country='cirJWyuMaXoBqEmxbdML', address='qGhXKxAFfIxzAMZdkhrk')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"faust_records/","title":"Faust integration","text":"<p>This library also has support to generate <code>Avro Schemas</code> from a <code>faust.Record</code> using <code>AvroRecord</code>. <code>AvroRecord</code> is just a class that inherits from <code>faust.Record</code> and <code>AvroModel</code> respectively.</p> <p>Note</p> <p>All the AvroModel features like <code>serialization</code>, <code>parsing objects</code>, <code>validation</code> and <code>fake</code>, are available with AvroRecord</p> <p>Example:</p> Basic usage<pre><code>import typing\nfrom faust.models import fields\nfrom dataclasses_avroschema.faust import AvroRecord\n\n\nclass UserAdvance(AvroRecord):\n    name: str\n    age: int\n    pets: typing.List[str] = fields.StringField(required=False, default=[\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = fields.IntegerField(required=False, default={\"key\": 1})\n    has_car: bool = fields.BooleanField(required=False, default=False)\n    favorite_colors: typing.Tuple[str] = fields.StringField(required=False, default=(\"BLUE\", \"YELLOW\", \"GREEN\"))\n    country: str = fields.StringField(required=False, default=\"Argentina\")\n    address: typing.Optional[str] = None\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema()\n</code></pre> <p>resulting in</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"pets\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"pet\"\n      },\n      \"default\": [\"dog\", \"cat\"]\n    },\n    {\n      \"name\": \"accounts\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"account\"\n      },\n      \"default\": {\"key\": 1}\n    },\n    {\n      \"name\": \"has_car\",\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    {\n      \"name\": \"favorite_colors\", \n      \"type\": {\n        \"type\": \"array\", \"items\": \"string\", \"name\": \"favorite_color\",\n        \"default\": [\"BLUE\", \"YELLOW\", \"GREEN\"]\n      }\n    },\n    {\n      \"name\": \"country\",\n      \"type\": \"string\",\n      \"default\": \"Argentina\"\n    },\n    {\n      \"name\": \"address\",\n      \"type\": [\"null\", \"string\"],\n      \"default\": null\n    }\n  ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"faust_records/#data-validation","title":"Data validation","text":"<p>For models there is no validation of data by default in <code>Faust</code>, however there is an option that will enable validation for all common JSON fields (int, float, str, etc.), and some commonly used Python ones (datetime, Decimal, etc.)</p> <p>In order to validate the data <code>validation=True</code> must be used as is described in tha faust documenation</p> Data validationNo Data validation Data validation<pre><code>import typing\nfrom faust.models import fields\nfrom dataclasses_avroschema.faust import AvroRecord\n\n\nclass UserAdvance(AvroRecord, validation=True):\n    name: str\n    age: int\n    pets: typing.List[str] = fields.StringField(required=False, default=['dog', 'cat'])\n    accounts: typing.Dict[str, int] = fields.IntegerField(required=False, default={\"key\": 1})\n    has_car: bool = fields.BooleanField(required=False, default=False)\n    favorite_colors: typing.Tuple[str] = fields.StringField(required=False, default=(\"BLUE\", \"YELLOW\", \"GREEN\"))\n    country: str = fields.StringField(required=False, default=\"Argentina\")\n    address: typing.Optional[str] = None\n\n    class Meta:\n        schema_doc = False\n\nUserAdvance(name=\"marcos\", age=\"bond\")\n\nValueError: invalid literal for int() with base 10: 'bond'\n</code></pre> <pre><code>import typing\n\nfrom dataclasses_avroschema.faust import AvroRecord\n\n\nclass UserAdvance(AvroRecord):\n    name: str\n    age: int\n    pets: typing.List[str] = fields.StringField(required=False, default=['dog', 'cat'])\n    accounts: typing.Dict[str, int] = fields.IntegerField(required=False, default={\"key\": 1})\n    has_car: bool = fields.BooleanField(required=False, default=False)\n    favorite_colors: typing.Tuple[str] = fields.StringField(required=False, default=(\"BLUE\", \"YELLOW\", \"GREEN\"))\n    country: str = fields.StringField(required=False, default=\"Argentina\")\n    address: typing.Optional[str] = None\n\n    class Meta:\n        schema_doc = False\n\nUserAdvance(name=\"marcos\", age=\"juan\")  # WRONG data\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"faust_records/#faust-and-dataclasses_avroschema-batteries","title":"Faust and dataclasses_avroschema batteries","text":""},{"location":"faust_records/#to-dict-to-json-and-serialization","title":"To dict, to json and serialization","text":"<pre><code>import typing\n\nfrom faust.models import fields\n\nfrom dataclasses_avroschema.faust import AvroRecord\n\n\nclass Address(AvroRecord):\n    street: str\n    street_number: int\n\n\nclass UserAdvance(AvroRecord):\n    name: str\n    age: int\n    address: Address\n    pets: typing.List[str] = fields.StringField(required=False, default=['dog', 'cat'])\n    accounts: typing.Dict[str, int] = fields.IntegerField(required=False, default={\"key\": 1})\n    has_car: bool = fields.BooleanField(required=False, default=False)\n    favorite_colors: typing.Tuple[str] = fields.StringField(required=False, default=(\"BLUE\", \"YELLOW\", \"GREEN\"))\n    country: str = fields.StringField(required=False, default=\"Argentina\")\n\n    class Meta:\n        schema_doc = False\n\n\nuser = UserAdvance(\n    name=\"bond\",\n    age=50, \n    address=Address(\n        street=\"Wilhelminastraat\",\n        street_number=29,\n    )\n)\n\n\nassert user.to_dict() == {\n    'name': 'bond', 'age': 50, \n    'address': {\n        'street': 'Wilhelminastraat', \n        'street_number': 29\n    }, \n    'pets': ['dog', 'cat'], \n    'accounts': {'key': 1},\n    'has_car': False,\n    'favorite_colors': ('BLUE', 'YELLOW', 'GREEN'), \n    'country': 'Argentina'\n}\n\nassert user.to_json(separators=(\",\",\":\",)) == \"\"\"{\"name\":\"bond\",\"age\":50,\"address\":{\"street\":\"Wilhelminastraat\",\"street_number\":29},\"pets\":[\"dog\",\"cat\"],\"accounts\":{\"key\":1},\"has_car\":false,\"favorite_colors\":[\"BLUE\",\"YELLOW\",\"GREEN\"],\"country\":\"Argentina\"}\"\"\"\n\nevent = user.serialize()\nassert event == b'\\x08bondd Wilhelminastraat:\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x06\\x08BLUE\\x0cYELLOW\\nGREEN\\x00\\x12Argentina'\n\nassert UserAdvance.deserialize(data=event) == UserAdvance(name='bond', age=50, address=Address(street='Wilhelminastraat', street_number=29), pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=('BLUE', 'YELLOW', 'GREEN'), country='Argentina')\n</code></pre>"},{"location":"fields_specification/","title":"Fields Specification","text":"<p>Apache Avro has <code>Primitive Types</code>, <code>Complex Types</code> and <code>Logical Types</code>, so we need to match these types with python types.</p>"},{"location":"fields_specification/#primitive-types-and-python-representation","title":"Primitive Types and python representation","text":"<p>The set of primitive type names is:</p> <ul> <li>null: no value</li> <li>boolean: a binary value</li> <li>int: 32-bit signed integer</li> <li>long: 64-bit signed integer</li> <li>float: single precision (32-bit) IEEE 754 floating-point number</li> <li>double: double precision (64-bit) IEEE 754 floating-point number</li> <li>bytes: sequence of 8-bit unsigned bytes</li> <li>string: unicode character sequence</li> </ul> <p>So, the previous types can be matched to:</p> Avro Type Python Type string str long int boolean bool double float null None bytes bytes int types.Int32 float types.Float32 <p>Since Python does not have native <code>int32</code> or <code>float32</code> types, use the <code>dataclasses_avroschema.types.Int32</code> and <code>dataclasses_avroschema.types.Float32</code> types to annotate your classes. These types are simple wrappers around Python's default <code>int</code> and <code>float</code> types.</p> <p>Note</p> <p>Primitive type names are also defined type names. Thus, for example, the schema \u201cstring\u201d is equivalent to: <code>{\"type\": \"string\"}</code></p> <p>Warning</p> <p>If you have to defined an <code>avro schema</code> with primitive type as defined type then set all the properties like <code>default</code>, <code>aliases</code>, etc in the <code>defined type</code></p> Primitive type as defined type<pre><code>{\n  \"name\": \"expirience\",\n  \"type\": {\"type\": \"int\", \"unit\": \"years\", \"default\": 10}\n}\n</code></pre>"},{"location":"fields_specification/#complex-types","title":"Complex Types","text":"<p>Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records.</p> Avro Type Python Type enums tuple arrays list maps dict fixed types.Fixed unions typing.Union records Python Class <ul> <li>Enums: Use the type name \"enum\" and support the following attributes:</li> <li>name: a JSON string providing the name of the enum (required).</li> <li>namespace: a JSON string that qualifies the name;</li> <li>aliases: a JSON array of strings, providing alternate names for this enum (optional).</li> <li>doc: a JSON string providing documentation to the user of this schema (optional).</li> <li>symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression A-Za-z_ (the same requirement as for names).</li> </ul> <p>When we want to define a <code>enum</code> type we should specify a default value because we need to define the <code>symbols</code> In future version we will have a custom enum type to avoid this</p> <ul> <li>Arrays: Use the type name \"array\" and support the following attribute:</li> <li>name: a JSON string providing the name of the enum (required).</li> <li> <p>items: the schema of the array's items.</p> </li> <li> <p>Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute:</p> </li> <li>name: a JSON string providing the name of the enum (required).</li> <li> <p>values: the schema of the map's values.</p> </li> <li> <p>Fixed uses the type name \"fixed\" and supports two attributes:</p> </li> <li>name: a string naming this fixed (required).</li> <li>namespace, a string that qualifies the name;</li> <li>aliases: a JSON array of strings, providing alternate names for this enum (optional).</li> <li> <p>size: an integer, specifying the number of bytes per value (required).</p> </li> <li> <p>Unions: <code>Unions</code> are represented using JSON arrays. For example, <code>[\"null\", \"string\"]</code> declares a schema which may be either a null or string. Under the Avro specifications, if a union field as a default, the type of the default must be the first listed type in the array. Dataclasses-avroschema will automatically generate the appropriate array if a default is provided. Note that an optional field (typing.Optional[T]) generates the union <code>[T, null]</code>, where <code>T</code> is the first element in the union. <code>None</code> will need to be explicitly declared the default to generate the appropriate schema, if the default should be <code>None/null</code>.</p> </li> <li> <p>Records: <code>Records</code> use the type name <code>record</code> and will represent the <code>Schema</code>.</p> </li> </ul>"},{"location":"fields_specification/#logical-types","title":"Logical Types","text":"<p>A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types.</p> <p>A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required.</p> <p>Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type.</p> <ul> <li> <p>Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar).</p> </li> <li> <p>Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000.</p> </li> <li> <p>Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC.</p> </li> <li> <p>UUID: Represents a uuid as a string</p> </li> <li> <p>Decimal: Represents a decimal.Decimal as bytes</p> </li> </ul> Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long time-micros types.TimeMicro long timestamp-millis datetime.datetime long timestamp-micros types.DateTimeMicro string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal types.condecimal"},{"location":"fields_specification/#avro-field-and-python-types-summary","title":"Avro Field and Python Types Summary","text":"python &lt;= 3.10python &gt;= 3.11 Python Type Avro Type Logical Type str string do not apply long int do not apply bool boolean do not apply double float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply enum.Enum enum do not apply types.Int32 int do not apply types.Float32 float do not apply typing.Union union do not apply typing.Optional union (with <code>null</code>) do not apply Python class record do not apply datetime.date int date datetime.time int time-millis types.TimeMicro long time-micros datetime.datetime long timestamp-millis types.DateTimeMicro long timestamp-micros decimal.Decimal bytes decimal uuid.uuid4 string uuid uuid.UUID string uuid Python Type Avro Type Logical Type str string do not apply long int do not apply bool boolean do not apply double float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply str, enum.Enum enum do not apply types.Int32 int do not apply types.Float32 float do not apply typing.Union union do not apply typing.Optional union (with <code>null</code>) do not apply Python class record do not apply datetime.date int date datetime.time int time-millis types.TimeMicro long time-micros datetime.datetime long timestamp-millis types.DateTimeMicro long timestamp-micros decimal.Decimal bytes decimal uuid.uuid4 string uuid uuid.UUID string uuid"},{"location":"fields_specification/#typingannotated","title":"typing.Annotated","text":"<p>All the types can be Annotated so <code>metadata</code> can be added to the fields. This library will use the <code>python type</code> to generate the <code>avro field</code> and it will ignore the extra <code>metadata</code>.</p> Annotated<pre><code>import dataclasses\nimport enum\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: typing.Annotated[str, \"string\"]\n    age: typing.Annotated[int, \"integer\"]\n    pets: typing.List[typing.Annotated[str, \"string\"]]\n    accounts: typing.Dict[str, typing.Annotated[int, \"integer\"]]\n    favorite_colors: typing.Annotated[FavoriteColor, \"a color enum\"]\n    has_car: typing.Annotated[bool, \"boolean\"] = False\n    country: str = \"Argentina\"\n    address: typing.Optional[typing.Annotated[str, \"string\"]] = None\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema()\n</code></pre> <p>resulting in</p> <pre><code>{\n  \"type\": \"record\", \n  \"name\": \"UserAdvance\", \n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n    {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n    {\"name\": \"favorite_colors\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n    {\"name\": \"has_car\", \"type\": \"boolean\", \"default\": false}, \n    {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n    {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"fields_specification/#typingliteral","title":"typing.Literal","text":"<p>Fields can be annotated with <code>typing.Literal</code> in accordance with PEP 586. Note that a literal field with multiple arguments (i.e. of the form <code>typing.Literal[v1, v2, v3]</code>) is interpreted as a union of literals (i.e. <code>typing.Union[typing.Literal[v1], typing.Literal[v2], typing.Literal[v3]]</code>) in line with the PEP.</p> python &lt;= 3.10python &gt;= 3.11 <pre><code>import enum\nimport typing\nfrom dataclasses import dataclass\nfrom dataclasses_avroschema import AvroModel\n\nclass E(enum.Enum):\n    ONE = \"one\"\n\n@dataclass\nclass T(AvroModel):\n    f: typing.Literal[None, 1, \"1\", True, b\"1\", E.ONE]\n\nprint(T.avro_schema())\n\"\"\"\n{\n  \"type\": \"record\",\n  \"name\": \"T\",\n  \"fields\": [\n    {\n      \"name\": \"f\",\n      \"type\": [\n        \"null\",\n        \"long\",\n        \"string\",\n        \"boolean\",\n        \"bytes\",\n        {\n          \"type\": \"enum\",\n          \"name\": \"E\",\n          \"symbols\": [\n            \"one\"\n          ]\n        }\n      ]\n    }\n  ]\n}\n\"\"\"\n</code></pre> <pre><code>import enum\nimport typing\nfrom dataclasses import dataclass\nfrom dataclasses_avroschema import AvroModel\n\nclass E(str, enum.Enum):\n    ONE = \"one\"\n\n@dataclass\nclass T(AvroModel):\n    f: typing.Literal[None, 1, \"1\", True, b\"1\", E.ONE]\n\nprint(T.avro_schema())\n\"\"\"\n{\n  \"type\": \"record\",\n  \"name\": \"T\",\n  \"fields\": [\n    {\n      \"name\": \"f\",\n      \"type\": [\n        \"null\",\n        \"long\",\n        \"string\",\n        \"boolean\",\n        \"bytes\",\n        {\n          \"type\": \"enum\",\n          \"name\": \"E\",\n          \"symbols\": [\n            \"one\"\n          ]\n        }\n      ]\n    }\n  ]\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"fields_specification/#adding-custom-field-level-attributes","title":"Adding Custom Field-level Attributes","text":"<p>You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a <code>\"doc\"</code> attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. <code>\"sensitivty\"</code>.</p> <p>When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as <code>\"name\"</code> and others are specific to the datatype (e.g. <code>array</code> will have the <code>items</code> attribute). In order to add custom fields, you can use the <code>field</code> descriptor of the built-in <code>dataclasses</code> package and provide a <code>dict</code> of key-value pairs to the <code>metadata</code> parameter as in <code>dataclasses.field(metadata={'doc': 'foo'})</code>.</p> Adding a doc attribute to fields<pre><code>from dataclasses import dataclass, field\nfrom dataclasses_avroschema import AvroModel, types\n\n@dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = field(metadata={'doc': 'bar'})\n    age: int = field(metadata={'doc': 'foo'})\n\nUser.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\", \"doc\": \"bar\"},\n        {\"name\": \"age\", \"type\": \"long\", \"doc\": \"foo\"}\n    ]\n}\n</code></pre> Adding an additional sensitivity attribute to fields.<pre><code>from dataclasses import dataclass, field\nfrom dataclasses_avroschema import AvroModel, types\n\n@dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = field(metadata={'doc': 'bar', 'sensitivity': 'HIGH'})\n    age: int = field(metadata={'doc': 'foo', 'sensitivity': 'MEDIUM'})\n\nUser.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\", \"doc\": \"bar\", \"sensitivity\": \"HIGH\"},\n        {\"name\": \"age\", \"type\": \"long\", \"doc\": \"foo\", \"sensitivity\": \"MEDIUM\"}\n    ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"fields_specification/#exclude-default-value-from-schema","title":"Exclude default value from schema","text":"<p>Sometimes it is useful to exclude <code>default</code> values in the final <code>avro schema</code>, for example when default values are dynamically generated. In the following example, we have an User with fields <code>id</code> and <code>created_at</code>, their default are generated when an instance is created. Because the defaults are dynamic then the <code>avro schema</code> will change every time that is generated.  It is possible to <code>exclude</code> the <code>default</code> value using the <code>exclude_default</code> in the <code>metadata</code>. This is applicable when using <code>default</code> or <code>default_factory</code></p> Schema with dynamic defaults <pre><code>import dataclasses\nimport datetime\nfrom uuid import UUID, uuid4\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    id: UUID = dataclasses.field(default_factory=uuid4)\n    created_at: datetime.datetime = dataclasses.field(\n        default_factory=lambda: datetime.datetime.now(tz=datetime.timezone.utc)\n    )\n\nUser.avro_schema_to_python()\n\n\n{\n  'type': 'record', \n  'name': 'User', \n  'fields': [\n    {\n      'name': 'uuid', \n      'type': {\n        'type': 'string', \n        'logicalType': 'uuid'\n      }, \n      'default': '3f70bc2f-f533-434e-ab9b-982477626419'  # IT WILL CHANGE EVERY TIME!!!\n    }, \n    {\n      'name': 'created_at', \n      'type': {\n        'type': 'long', \n        'logicalType': 'timestamp-millis'\n      }, \n      'default': 1705154403499  # IT WILL CHANGE EVERY TIME!!!\n    }\n  ]\n}\n</code></pre> Exlude default from schema <pre><code>import dataclasses\nimport datetime\nfrom uuid import UUID, uuid4\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    id: UUID = dataclasses.field(default_factory=uuid4, metadata={\"exclude_default\": True})\n    created_at: datetime.datetime = dataclasses.field(\n      default_factory=lambda: datetime.datetime.now(tz=datetime.timezone.utc),\n      metadata={\"exclude_default\": True}\n  )\n\nUser.avro_schema_to_python()\n\n\n{\n  'type': 'record', \n  'name': 'User', \n  'fields': [\n    {\n      'name': 'uuid', \n      'type': {\n        'type': 'string', \n        'logicalType': 'uuid'\n      }\n    }, \n    {\n      'name': 'created_at', \n      'type': {\n        'type': 'long', \n        'logicalType': 'timestamp-millis'\n      }\n    }\n  ]\n}\n</code></pre> <p>Note</p> <p>This is also applicable for <code>AvroBaseModel</code> (pydantic)</p>"},{"location":"fields_specification/#fields-with-custom-inner-names","title":"Fields with custom inner names","text":"<p>Some avro fields like <code>arrays</code>, <code>map</code> and <code>fixed</code> define an <code>inner name</code> besides the <code>field name</code>. For this use cases, the <code>metadata</code> property <code>inner-name</code> must be defined, for example:</p> <pre><code>from dataclasses_avroschema import AvroModel\nfrom dataclasses_avroschema import types\nimport dataclasses\nimport typing\n\n\n@dataclasses.dataclass\nclass DeliveryBatch(AvroModel):\n    receivers_payload: typing.List[str] = dataclasses.field(metadata={'inner_name': 'my_custom_name'})\n    accounts: typing.Dict[str, str] = dataclasses.field(metadata={'inner_name': 'my_account'})\n    md5: types.confixed(size=16, namespace=\"md5\", aliases=['md5', 'hash']) = dataclasses.field(metadata={'inner_name': 'my_md5'})\n</code></pre> <p>which will produce the following schema:</p> <pre><code>{\n\"type\": \"record\",\n\"name\": \"DeliveryBatch\",\n\"fields\": [\n    {\"name\": \"receivers_payload\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"my_custom_name\"}},\n    {\n        \"name\": \"accounts\",\n        \"type\": {\"type\": \"map\", \"values\": \"string\", \"name\": \"my_account\"}\n    },\n    {\n        \"name\": \"md5\",\n        \"type\": {\n            \"type\": \"fixed\",\n            \"name\": \"my_md5\",\n            \"size\": 16,\n            \"namespace\": \"md5\",\n            \"aliases\": [\"md5\", \"hash\"]\n        }\n    },\n  ]\n}\n</code></pre>"},{"location":"good_practices/","title":"Streaming","text":""},{"location":"good_practices/#schema-server-and-avromodel","title":"Schema server and AvroModel","text":"<p>First, let's clarify what a schema server is: It is a <code>central place/repository</code> that contains schemas with formats like <code>avro</code>, <code>json</code> or <code>protobuf</code>, with the purpose of exposing them through an <code>API</code>, so applications can access them and <code>serialize/deserialize</code> events. The schema server could have a <code>RESTful</code> interface so tasks like <code>create</code>, <code>delete</code> <code>get</code> schemas can be performed easily. </p> <p>In a <code>pythonic world</code>, you wouldn't need a <code>schema server</code> because using only the <code>AvroModel</code> will be enough as all the teams in your organization will use the same models, but this is not always the case. Somethimes, in big companies teams use different programming languages to talk the streaming layer, like <code>python</code>, <code>java</code>, <code>go</code>, etc. In this sense, you need a way to share <code>schemas</code> and you will need a <code>schema server</code>, otherwise it will be really hard to maintain the whole proccess.</p> <p>If you have a <code>Schema Server</code> and you want to use <code>AvroModel</code>, I would recommend you to add the <code>schema_id</code> in the <code>Model.Meta</code> that matches the schema in the <code>schema server</code>:</p> Include schema_id in Meta<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id}\n</code></pre> <p>The purpose of the <code>schema_id</code> is to give a fast notion what the model is representing. Also, could be used as <code>documentation</code></p>"},{"location":"good_practices/#include-event-metadata","title":"Include event metadata","text":"<p><code>avro schemas</code> are used widely in <code>streaming</code> to <code>serialize</code> events, and with <code>dataclasses-avroschemas</code> it is straigtforward. Once  that you have the event, it is a good practice to also add the <code>event metadata</code> at the moment of <code>producing</code> so <code>consumers</code> will know what to do.</p> <p>Event metadata:</p> <ul> <li><code>content-type</code> or <code>serialization-type</code>: represents the way that the event was serialized. This could be <code>avro</code> or <code>avro-json</code> for example.</li> <li><code>schema-id</code>: represents the <code>schema-id</code> that was used to serialize the event if exist.</li> </ul> Produce event with metadata<pre><code>import asyncio\nimport dataclasses\nfrom dataclasses_avroschema import AvroModel\nfrom aiokafka import AIOKafkaProducer\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Confluent way: https://my-schema-server/schemas/ids/{int: id}\n\n\nasync def produce():\n    # Naive example of producing an event\n\n    producer = AIOKafkaProducer(bootstrap_servers='localhost:9092')\n    await producer.start()\n\n    user = User(\"Bond\", age=\"50\")\n\n    # create the event\n    event = user.serialize()\n    headers = [\n        (\"content-type\": b\"avro\"),\n        (\"schema-id\": User.Meta.schema_id.encode()),\n    ]\n\n    await producer.send_and_wait(\"my_topic\", value=event, headers=headers)\n    await producer.stop()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(produce)\n</code></pre>"},{"location":"good_practices/#define-namespaces","title":"Define Namespaces","text":"<p>When there are types that are used more than once in a schema, for example <code>records</code> and <code>enums</code> it is a good practice to define <code>namespace</code> for the repeated type. This will allow you to identify more easily the <code>types</code>, specially if you have all the schemas in a <code>schema server</code> like <code>confluent</code>.</p> <p>Uses cases:</p> <ul> <li>Reusing types with records</li> <li>Reusing types with enums</li> </ul>"},{"location":"logical_types/","title":"Logical Types","text":"<p>The following list represent the avro logical types mapped to python types:</p> Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long time-micros types.TimeMicro long timestamp-millis datetime.datetime long timestamp-micros types.DateTimeMicro double timedelta datetime.timedelta string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal types.condecimal <p>Note</p> <p>Custom <code>logicalTypes</code> are not supported</p>"},{"location":"logical_types/#date","title":"Date","text":"Date example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass DateLogicalType(AvroModel):\n    \"Date type\"\n    birthday: datetime.date\n    meeting_date: typing.Optional[datetime.date] = None\n    release_datetime: datetime.date = a_datetime.date()\n\n\nDateLogicalType.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DateLogicalType\",\n  \"fields\": [\n    {\n      \"name\": \"birthday\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"date\"}},\n    {\n      \"name\": \"meeting_date\",\n      \"type\": [\"null\", {\"type\": \"int\", \"logicalType\": \"date\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_datetime\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"date\"},\n      \"default\": 18181\n    }\n  ],\n  \"doc\": \"Date type\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/#time","title":"Time","text":"Time example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel, TimeMicro\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass TimeLogicalTypes(AvroModel):\n    \"Time logical types\"\n    birthday_time: datetime.time\n    meeting_time: typing.Optional[datetime.time] = None\n    release_time: datetime.time = a_datetime.time()\n    release_time_micro: TimeMicro = a_datetime.time()\n\nTimeLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"TimeLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"birthday_time\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"time-millis\"}\n    },\n    {\n      \"name\": \"meeting_time\",\n      \"type\": [\"null\", {\"type\": \"int\", \"logicalType\": \"time-millis\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_time\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"time-millis\"},\n      \"default\": 64662000\n    },\n    {\n      \"name\": \"release_time_micro\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"time-micros\"},\n      \"default\": 64662000000\n    }\n  ],\n  \"doc\": \"Time logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>To use <code>time-micros</code> in avro schemas you need to use <code>types.TimeMicro</code></p>"},{"location":"logical_types/#datetime","title":"Datetime","text":"DateTime example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel, DateTimeMicro\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass DatetimeLogicalType(AvroModel):\n    \"Datetime logical types\"\n    birthday: datetime.datetime\n    meeting_time: typing.Optional[datetime.datetime] = None\n    release_datetime: datetime.datetime = a_datetime\n    release_datetime_micro: DateTimeMicro = a_datetime\n\nDatetimeLogicalType.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DatetimeLogicalType\",\n  \"fields\": [\n    {\n      \"name\": \"birthday\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"meeting_time\",\n      \"type\": [\"nul\", {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_datetime\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"},\n      \"default\": 1570903062000\n    },\n    {\n      \"name\": \"release_datetime_micro\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-micros\"},\n      \"default\": 1570903062000000\n    }\n  ],\n  \"doc\": \"Datetime logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>To use <code>timestamp-micros</code> in avro schemas you need to use <code>types.DateTimeMicro</code></p>"},{"location":"logical_types/#timedelta","title":"Timedelta","text":"<p><code>timedelta</code> fields are serialized to a <code>double</code> number of seconds.</p> Timedelta example<pre><code>import datetime\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\ndelta = datetime.timedelta(weeks=1, days=2, hours=3, minutes=4, seconds=5, milliseconds=6, microseconds=7)\n\n@dataclasses.dataclass\nclass TimedeltaLogicalType(AvroModel):\n    \"Timedelta logical type\"\n    time_elapsed: datetime.timedelta = delta\n\nDatetimeLogicalType.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DatetimeLogicalType\",\n  \"fields\": [\n    {\n      \"name\": \"time_elapsed\",\n      \"type\": {\n        \"type\": \"double\",\n        \"logicalType\": \"dataclasses-avroschema-timedelta\"\n      },\n      \"default\": 788645.006007\n    }\n  ],\n  \"doc\": \"Timedelta logical type\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/#uuid","title":"UUID","text":"UUID example<pre><code>import uuid\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UUIDLogicalTypes(AvroModel):\n    \"UUID logical types\"\n    uuid_1: uuid.uuid4\n    uuid_2: typing.Optional[uuid.uuid4] = None\n    event_uuid: uuid.uuid4 = uuid.uuid4()\n\nUUIDLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UUIDLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"uuid_1\",\n      \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\"}\n    },\n    {\n      \"name\": \"uuid_2\",\n      \"type\": [\"null\", {\"type\": \"string\", \"logicalType\": \"uuid\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"event_uuid\",\n      \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\"},\n      \"default\": \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\"\n    }\n  ],\n  \"doc\": \"UUID logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/#decimal","title":"Decimal","text":"<p><code>Decimal</code> types in <code>avro</code> must specify two required attributes: <code>precision</code> and <code>scale</code>. <code>Precision</code> represents the amount of digits and <code>scale</code> the amount of decimal places. Because with the python type <code>decimal.Decimal</code> is not possible to supply the required arguments, <code>dataclasses-avroschema</code> provides a funtion to create the decimals. The function <code>types.condecimal</code> annotates the <code>decimal.Decimal</code> type and it adds the required attibutes.</p>"},{"location":"logical_types/#arguments-to-condecimal","title":"Arguments to condecimal","text":"<p>The following arguments are available when using the condecimal type function</p> <ul> <li>max_digits (int): total number digits</li> <li>decimal_places (int): total decimal places</li> </ul> Decimal example<pre><code>import decimal\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass DecimalLogicalTypes(AvroModel):\n    \"Decimal logical types\"\n    money: types.condecimal(max_digits=3, decimal_places=2)\n    decimal_with_default: types.condecimal(max_digits=3, decimal_places=2) = decimal.Decimal('3.14')\n    optional_decimal: typing.Optional[types.condecimal(max_digits=3, decimal_places=2)] = None\n\nDecimalLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DecimalLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"money\",\n      \"type\": {\n        \"type\": \"bytes\",\n        \"logicalType\": \"decimal\",\n        \"precision\": 3,\n        \"scale\": 2\n      }\n    },\n    {\n      \"name\": \"decimal_with_default\",\n      \"type\": {\n        \"type\": \"bytes\",\n        \"logicalType\": \"decimal\",\n        \"precision\": 3,\n        \"scale\": 2\n      },\n      \"default\": \"\\\\u013a\"\n    },\n    {\n      \"name\": \"optional_decimal\",\n      \"type\": [\n        \"null\",\n        {\n          \"type\": \"bytes\",\n          \"logicalType\": \"decimal\",\n          \"precision\": 3,\n          \"scale\": 2\n        }\n      ]\n      \"default\": \"null\"\n    }\n  ],\n  \"doc\": \"Decimal logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"migration_guide/","title":"Migration from previous versions to 0.51.0","text":"<ul> <li> <p>In this version was introduced the namespace <code>dataclasses_avroschema.pydantic</code> and the nanespace <code>dataclasses_avroschema.avrodantic</code> was removed. To make use of <code>AvroBaseModel</code> then replade the import <code>from dataclasses_avroschema.avrodantic import AvroBaseModel</code> by <code>from dataclasses_avroschema.pydantic import AvroBaseModel</code></p> </li> <li> <p>If you are using <code>AvroModel</code> field attributes like <code>klass</code>, <code>metadata</code>, etc then all of them now are private (<code>_klass</code>, <code>_metadata</code>, etc). By design was intended not used them, now it is explicit.</p> </li> </ul>"},{"location":"migration_guide/#migration-from-previous-versions-to-0451","title":"Migration from previous versions to 0.45.1","text":"<ul> <li>Previously <code>Unions</code> that had <code>default_factory</code> where force to return a <code>callable</code> which the return type must be <code>list</code> or <code>dict</code>, now is not the case any more. If you use <code>default_factory</code> makes sure that it is a <code>callable</code>, that's it. This new fix also will be complain with type checkers.</li> </ul> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Bus(AvroModel):\n    \"A Bus\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass Car(AvroModel):\n    \"A Car\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n  \"Some Unions\"\n  lake_trip: Bus | Car\n  river_trip: Bus | Car | None = None\n  mountain_trip: Bus | Car = dataclasses.field(\n      default_factory=lambda: Bus(engine_name=\"honda\"))\n  # mountain_trip: Bus | Car = dataclasses.field(default_factory=lambda: {\"engine_name\": \"honda\"}) # OLD WAY\n\nUnionSchema.avro_schema()\n</code></pre> <ul> <li><code>Field</code> internal api updated:</li> <li><code>to_avro</code> was renamed to <code>default_to_avro</code> and is an instance method</li> </ul>"},{"location":"migration_guide/#migration-from-previous-versions-to-0270","title":"Migration from previous versions to 0.27.0","text":"python &lt;= 3.10python &gt;= 3.11 <ul> <li><code>types.Enum</code> was replaced with <code>enum.Enum</code>. You must create your custom enum, example:</li> </ul> <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel, types\n\n\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"], default=\"BLUE\")  # --&gt; replace with field!!!\n</code></pre> <p>should be replaced by:</p> <pre><code>import enum\nimport dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\nclass UserAdvance:\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE  # --&gt; field updated!!!\n</code></pre> <ul> <li><code>types.Enum</code> was replaced with <code>str, enum.Enum</code>. You must create your custom enum, example:</li> </ul> <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel, types\n\n\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"], default=\"BLUE\")  # --&gt; replace with field!!!\n</code></pre> <p>should be replaced by:</p> <pre><code>import enum\nimport dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n# New enum!!\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE  # --&gt; field updated!!!\n</code></pre>"},{"location":"migration_guide/#migration-from-previous-versions-to-0230","title":"Migration from previous versions to 0.23.0","text":"<ol> <li>Now the name for Nested record uses the <code>class.__name__</code> instead of <code>`class.__name__.lower()_record</code>.</li> </ol> <p>having this schemas:</p> <pre><code>import typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.Dict[str, Address]\n\n\n# PREVIOUS\nUser.avro_schema()\n{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"address_record\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}\n\n\n# VERSIONS 0.23.0\nUser.avro_schema()\n{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}\n</code></pre> <ol> <li>Now we use <code>namespaces</code> when same types are referenced multiple times (DRY), so you MUST define the property <code>namespace</code>:</li> </ol> <pre><code>import dataclasses\nimport datetime\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"  # REQUIRED!!!!\n\n\n@dataclasses.dataclass\nclass Trip(AvroModel):\n    start_time: datetime.datetime\n    start_location: Location\n    finish_time: datetime.datetime\n    finish_location: Location\n\nTrip.avro_schema_to_python()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"start_location\",\n      \"type\": {\"type\": \"record\",\n      \"name\": \"Location\",\n        \"fields\": [\n          {\"name\": \"latitude\", \"type\": \"double\"},\n          {\"name\": \"longitude\", \"type\": \"double\"}\n        ],\n      \"doc\": \"Location(latitude: float, longitude: float)\",\n      \"namespace\": \"types.location_type\"}},\n    {\n      \"name\": \"finish_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"finish_location\", \"type\": \"types.location_type.Location\"  // using the namespace\n    }\n  ],\n  \"doc\": \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\"\n}\n</code></pre>"},{"location":"migration_guide/#migration-from-previous-versions-to-0140","title":"Migration from previous versions to 0.14.0","text":"<p>Now all the dataclasses should inheritance from <code>AvroModel</code> and not use anymore the <code>SchemaGenerator</code>:</p> <pre><code># Versions &lt; 0.14.0\nimport dataclasses\nimport typing\nfrom dataclasses_avroschema import SchemaGenerator, types\n\n\nclass User:\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"])\n    country: str = \"Argentina\"\n    address: str = None\n\nSchemaGenerator(User).avro_schema()\n</code></pre>"},{"location":"migration_guide/#new-version","title":"new version","text":"<pre><code>import dataclasses\nimport typing\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"])\n    country: str = \"Argentina\"\n    address: str = None\n\n\nUser.avro_schema()\n</code></pre> <p>Another changes introduced was the way that extra avro attributes are represented, like <code>namespace</code>, <code>aliases</code> and whether to include <code>avro documentation</code>:</p> <pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass User:\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    def extra_avro_attributes() -&gt; typing.Dict[str, typing.Any]:\n        return {\n            \"namespace\": \"test.com.ar/user/v1\",\n            \"aliases\": [\"User\", \"My favorite User\"]\n        }\n\nSchemaGenerator(User, include_schema_doc=False).avro_schema()\n\n# Now is perform using a Meta class\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_doc = False\n        namespace = \"test.com.ar/user/v1\"\n        aliases = [\"User\", \"My favorite User\"]\n</code></pre>"},{"location":"model_generator/","title":"Model Generator","text":"<p>This section describe how to convert <code>python classes</code> from an <code>avro schema</code> (avsc files). This is the inverse process that the library aims to.</p> <p>ModelGenerator converts an avro schema to classes</p> <p><code>Avro schema</code> --&gt; <code>Python class</code></p> <p>This class will be in charge of render all the python types in a proper way. The rendered result is a string that contains proper identation, decorators, imports and any extras so the result can be saved in a file and it will be ready to use.</p> <p>Example</p> <pre><code>from dataclasses_avroschema import ModelGenerator\n\nmodel_generator = ModelGenerator()\n\nschema = {\n    \"type\": \"record\",\n    \"namespace\": \"com.kubertenes\",\n    \"name\": \"AvroDeployment\",\n    \"fields\": [\n        {\"name\": \"image\", \"type\": \"string\"},\n        {\"name\": \"replicas\", \"type\": \"int\"},\n        {\"name\": \"port\", \"type\": \"int\"},\n    ],\n}\n\nresult = model_generator.render(schema=schema)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then explore the module <code>models.py</code>, the result must be</p> Code generated<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses_avroschema import types\n\n\n@dataclasses.dataclass\nclass AvroDeployment(AvroModel):\n    image: str\n    replicas: types.Int32\n    port: types.Int32\n\n    class Meta:\n        namespace = \"com.kubertenes\"\n</code></pre> <p>Note</p> <p>In future releases it will be possible to generate models for other programming langagues like <code>java</code> and <code>rust</code></p> <p>Note</p> <p>You can also use dc-avro to generate the models from the command line</p>"},{"location":"model_generator/#mapping-avro-fields-to-python-fields-summary","title":"Mapping <code>avro fields</code> to <code>python fields</code> summary","text":"python &lt;= 3.10python &gt;= 3.11 Avro Type Python Type string str int long boolean bool float double null None bytes bytes array typing.List map typing.Dict fixed types.confixed enum enum.Enum int types.Int32 float types.Float32 union typing.Union record Python class date datetime.date time-millis datetime.time time-micros types.TimeMicro timestamp-millis datetime.datetime timestamp-micros types.DateTimeMicro decimal types.condecimal uuid uuid.UUID Avro Type Python Type string str int long boolean bool float double null None bytes bytes array typing.List map typing.Dict fixed types.confixed enum str, enum.Enum int types.Int32 float types.Float32 union typing.Union record Python class date datetime.date time-millis datetime.time time-micros types.TimeMicro timestamp-millis datetime.datetime timestamp-micros types.DateTimeMicro decimal types.condecimal uuid uuid.UUID"},{"location":"model_generator/#render-a-python-module","title":"Render a Python module","text":"<p>It's also possible to generate a Python module containing classes from multiple schemas using <code>render_module</code>.</p> <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nmodel_generator = ModelGenerator()\n\nuser_schema = {\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\", \"default\": \"marcos\"},\n        {\"name\": \"age\", \"type\": \"int\"},\n    ],\n}\naddress_schema = {\n    \"type\": \"record\",\n    \"name\": \"Address\",\n    \"fields\": [\n        {\"name\": \"street\", \"type\": \"string\"},\n        {\"name\": \"street_number\", \"type\": \"long\"},\n    ],\n}\n\nresult = model_generator.render_module(schemas=[user_schema, address_schema], model_type=ModelType.DATACLASS.value)\n\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then, the end result is:</p> <pre><code># models.py\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses_avroschema import types\nimport dataclasses\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    age: types.Int32\n    name: str = \"marcos\"\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    street: str\n    street_number: int\n</code></pre> <p>Generating a single module from multiple schemas is useful for example to group schemas that belong to the same namespace.</p>"},{"location":"model_generator/#logicaltypes","title":"LogicalTypes","text":"<p>Native <code>logicalTypes</code> are supported by <code>dataclasses-avroschema</code> but custom ones are not. If you defined a custom <code>logicalType</code> then the fallback is used when generating the field. In the next example we have a <code>logicalType</code> defined as <code>url</code>, which is not a native one, then the model generated will use <code>string</code></p> <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nmodel_generator = ModelGenerator()\n\n\nschema = {\n    \"type\": \"record\",\n    \"name\": \"TestEvent\",\n    \"fields\": [\n        {\n            \"name\": \"regular\",\n            \"type\": {\n                \"type\": \"string\",\n                \"logicalType\": \"url\"\n            },\n            \"doc\": \"Urls\"\n        }\n    ],\n}\n\nprint(model_generator.render(schema=schema))\n\n\"\"\"\nfrom dataclasses_avroschema import AvroModel\nimport dataclasses\n\n\n@dataclasses.dataclass\nclass TestEvent(AvroModel):\n    regular: str = dataclasses.field(metadata={'doc': 'Urls'})\n\"\"\"\n</code></pre>"},{"location":"model_generator/#render-pydantic-models","title":"Render Pydantic models","text":"<p>It is also possible to render <code>BaseModel</code> (pydantic) and <code>AvroBaseModel</code> (avro + pydantic) models as well. The end result will also include the necessaty imports and the use of <code>pydantic.Field</code> in case that it is needed:</p> <p>For example:</p> <pre><code>schema = {\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"friend\", \"type\": [\"null\", \"User\"], \"default\": None},\n        {\"name\": \"relatives\", \"type\": {\"type\": \"array\", \"items\": \"User\", \"name\": \"relative\"}, \"default\": []},\n        {\"name\": \"teammates\", \"type\": {\"type\": \"map\", \"values\": \"User\", \"name\": \"teammate\"}, \"default\": {}},\n        {\"name\": \"money\", \"type\": {\"type\": \"bytes\", \"logicalType\": \"decimal\", \"precision\": 10, \"scale\": 3}},\n    ],\n}\n</code></pre> <p>and then render the result:</p> Pydantic modelsAvrodantic models <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema, model_type=ModelType.PYDANTIC.value)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n\n# models.py\nfrom pydantic import BaseModel\nfrom pydantic import Field\nfrom pydantic import condecimal\nimport typing\n\n\nclass User(BaseModel):\n    name: str\n    age: int\n    money: condecimal(max_digits=10, decimal_places=3)\n    friend: typing.Optional[typing.Type[\"User\"]] = None\n    relatives: typing.List[typing.Type[\"User\"]] = Field(default_factory=list)\n    teammates: typing.Dict[str, typing.Type[\"User\"]] = Field(default_factory=dict)\n</code></pre> <pre><code>from dataclasses_avroschema import ModelGenerator\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema, model_type=ModelType.AVRODANTIC.value)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n\n# models.py\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\nfrom pydantic import Field\nfrom pydantic import condecimal\nimport typing\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    money: condecimal(max_digits=10, decimal_places=3)\n    friend: typing.Optional[typing.Type[\"User\"]] = None\n    relatives: typing.List[typing.Type[\"User\"]] = Field(default_factory=list)\n    teammates: typing.Dict[str, typing.Type[\"User\"]] = Field(default_factory=dict)\n</code></pre> <p>Note</p> <p>Use the <code>dataclasses_avroschema.BaseClassEnum</code> to specify the <code>base class</code></p> <p>Note</p> <p><code>decimal.Decimal</code> are created using <code>pydantic condecimal</code></p> <p>Note</p> <p><code>uuid</code> types are created using <code>pydantic.UUID4</code></p>"},{"location":"model_generator/#malformed-schemas","title":"Malformed schemas","text":"<p>Some times there are valid avro schemas but we could say that it is \"malformed\", for example the following schema has a field name called <code>Address</code> which is exactly the same name as the record <code>Address</code>.</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"Address\",  # The field name is the same as the record name\n      \"type\": [\n        \"null\",\n        {\n            \"type\": \"record\",\n            \"name\": \"Address\",\n            \"fields\": [\n            {\n                \"name\": \"name\",\n                \"type\": \"string\"\n            }\n            ]\n        },\n      ],\n      \"default\": None,\n    }\n  ]\n}\n</code></pre> <p>If we try to generate the python models that correspond with the previous schema we end up with the following models. The result is correct because it translate to python what the schema represents, but if we checked the <code>annotations</code> we see that <code>Address</code> is <code>overshadowed</code></p> <pre><code>from dataclasses_avroschema import AvroModel\nimport dataclasses\nimport typing\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    name: str\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    Address: typing.Optional[Address] = None\n\n# Address` is `overshadowed` !!!\nprint(User.__annotations__)\n# &gt;&gt;&gt; {'name': str, 'age': int, 'Address': NoneType}\n\n# We do not want this!!!\nprint(User.fake())\n# &gt;&gt;&gt; User(name='ftXgdDSUzdUIamiiHOiS', age=2422, Address=None)  \n</code></pre> <p>If we rename the field name <code>Address</code> to <code>address</code> in the schema:</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"address\",  # RENAMED!!!\n      \"type\": [\n        \"null\",\n        {\n            \"type\": \"record\",\n            \"name\": \"Address\",\n            \"fields\": [\n            {\n                \"name\": \"name\",\n                \"type\": \"string\"\n            }\n            ]\n        },\n      ],\n      \"default\": None,\n    }\n  ]\n}\n</code></pre> <p>we get a proper result:</p> <pre><code>from dataclasses_avroschema import AvroModel\nimport dataclasses\nimport typing\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    name: str\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    address: typing.Optional[Address] = None\n\nprint(User.__annotations__)\n# &gt;&gt;&gt; {'name': str, 'age': int, 'address': typing.Optional[__main__.Address]}\n\nprint(User.fake())\n# &gt;&gt;&gt; User(name='JBZdhEWdXwFLQitWCjkc', age=3406, address=Address(name='AhlQsvXnkpcPZJvRSXLr'))\n</code></pre>"},{"location":"model_generator/#schema-with-invalid-python-identifiers","title":"Schema with invalid python identifiers","text":"<p><code>avro schemas</code> could contain field names that are not valid <code>python identifiers</code>, for example <code>street-name</code>. If we have the following <code>avro schema</code> the <code>python model</code> generated from it will generate <code>valid identifiers</code>, in this case and <code>street_name</code>  and <code>street_number</code></p> <pre><code>from dataclasses_avroschema import ModelGenerator\n\n\nschema = {\n    \"type\": \"record\",\n    \"name\": \"Address\",\n    \"fields\": [\n        {\"name\": \"street-name\", \"type\": \"string\"},\n        {\"name\": \"street-number\", \"type\": \"long\"}\n    ]\n}\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then the result will be:</p> <pre><code># models.py\nfrom dataclasses_avroschema import AvroModel\nimport dataclasses\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    street_name: str\n    street_number: int\n</code></pre> <p>Warning</p> <p>If you try to generate the <code>schema</code> from the model, both schemas won't match. You might have to use the case functionality</p>"},{"location":"model_generator/#field-order","title":"Field order","text":"<p>Sometimes we have to work with schemas that were created by a third party and we do not have control over them. Those schemas can contain optional fields declared before required fields, which means that and invalid model will be generated. To avoid this problem the <code>field_order</code> property is used in the generation process. For example the following schema contains the field <code>has_pets</code> (optional) before required fields:</p> <pre><code>from dataclasses_avroschema import ModelGenerator\n\n\nschema = {\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": False},\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3}\n  ],\n  \"doc\": \"My User Class\",\n}\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then the result will be:</p> <pre><code># models.py\nfrom dataclasses_avroschema import AvroModel\nimport dataclasses\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"\"\"\n    My User Class\n    \"\"\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        field_order = ['has_pets', 'name', 'age', 'money']\n</code></pre>"},{"location":"model_generator/#rendering-enums","title":"Rendering Enums","text":"<p>Because <code>avro enums</code> are represented by a python class, it is also possible to render them in isolation, for example:</p> <pre><code>from dataclasses_avroschema import ModelGenerator\n\n\nenum_schema = {\n    \"type\": \"enum\",\n    \"name\": \"Color\",\n    \"symbols\": [\n        \"red\",\n        \"blue\",\n    ],\n    \"default\": \"blue\",\n}\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=enum_schema)\n\nprint(result)\n</code></pre> <p>Resulting in</p> python &lt;= 3.10python &gt;= 3.11 <pre><code>import enum\n\n\nclass Color(enum.Enum):\n    RED = \"red\"\n    BLUE = \"blue\"\n\n    class Meta:\n        default = \"blue\"\n</code></pre> <pre><code>import enum\n\n\nclass Color(str, enum.Enum):\n    RED = \"red\"\n    BLUE = \"blue\"\n\n    @enum.nonmember\n    class Meta:\n        default = \"blue\"\n</code></pre>"},{"location":"model_generator/#enums-and-case-sensitivity","title":"Enums and case sensitivity","text":"<p>Sometimes there are schemas that contains the <code>symbols</code> which are case sensivity, for example <code>\"symbols\": [\"P\", \"p\"]</code>. Having something like that is NOT reccomended at all because it is meaninless, really hard to undestand the intention of it. Avoid it!!!</p> <p>When the schema generator encounter this situation it can not generated the proper <code>enum</code> with <code>uppercases</code> key so it will use the <code>symbol</code> without any transformation</p> <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nschema = {\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\": [\n        {\n            \"name\": \"unit_multi_player\",\n            \"type\": {\n                \"type\": \"enum\",\n                \"name\": \"unit_multi_player\",\n                \"symbols\": [\"Q\", \"q\"],\n            },\n        }\n    ],\n}\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema, model_type=ModelType.DATACLASS.value)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then the result will be:</p> python &lt;= 3.10python &gt;= 3.11 <pre><code># models.py\nfrom dataclasses_avroschema import AvroModel\nimport dataclasses\nimport enum\n\n\nclass UnitMultiPlayer(enum.Enum):\n    Q = \"Q\"\n    q = \"q\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    unit_multi_player: UnitMultiPlayer\n</code></pre> <pre><code># models.py\nfrom dataclasses_avroschema import AvroModel\nimport dataclasses\nimport enum\n\n\nclass UnitMultiPlayer(str, enum.Enum):\n    Q = \"Q\"\n    q = \"q\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    unit_multi_player: UnitMultiPlayer\n</code></pre> <p>As the example shows the second enum member <code>UnitMultiPlayer.p</code> is not in uppercase otherwise will collide with the first member <code>UnitMultiPlayer.P</code></p>"},{"location":"model_generator/#original-schema-string","title":"Original schema string","text":"<p>Ideally, the schema from the generated model must perfectly match the original schema, unfortunately that is not always the case when avro types, that have inner names (arrays, enums, fixed and maps), are used.</p> <p>To counteract a potential mismatch when referring to the schema using <code>GeneratedModel.avro_schema()</code>, which returns a generated schema based on the model. It is possible to specify to include the original schema string when using the ModelGenerator specifying <code>include_original_schema=True</code></p> <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nschema = {\n    \"type\": \"record\",\n    \"namespace\": \"com.kubertenes\",\n    \"name\": \"AvroDeployment\",\n    \"fields\": [\n        {\"name\": \"image\", \"type\": \"string\"},\n        {\"name\": \"replicas\", \"type\": \"int\"},\n        {\"name\": \"port\", \"type\": \"int\"},\n    ],\n}\n\nmodel_generator = ModelGenerator()\nresult = model_generator.render(schema=schema, model_type=ModelType.DATACLASS.value, include_original_schema=True)\n\n# save the result in a file\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>Then the result will be:</p> <pre><code># models.py\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses_avroschema import types\n\n\n@dataclasses.dataclass\nclass AvroDeployment(AvroModel):\n    image: str\n    replicas: types.Int32\n    port: types.Int32\n\n    class Meta:\n        namespace = \"com.kubertenes\"\n        original_schema = '{\"type\": \"record\", \"namespace\": \"com.kubertenes\", \"name\": \"AvroDeployment\", \"fields\": [{\"name\": \"image\", \"type\": \"string\"}, {\"name\": \"replicas\", \"type\": \"int\"}, {\"name\": \"port\", \"type\": \"int\"}]}'\n</code></pre> <p>As the example shows, the Meta class of AvroDeployment, now contains an \"original_schema\" field <code>AvroDeployment.Meta.original_schema</code>, which can be referred to instead. </p>"},{"location":"primitive_types/","title":"Primitive Types","text":"<p>The following list represent the avro primitive types mapped to python types:</p> Avro Type Python Type string str int,long int boolean bool float,double float null None bytes bytes"},{"location":"primitive_types/#examples","title":"Examples","text":"Primitive types<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    height: types.Float32\n    weight: types.Int32\n    is_student: bool\n    money_available: float\n    encoded: bytes\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"height\",\n      \"type\": \"float\"\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": \"int\"\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": \"boolean\"\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": \"double\"\n    },\n    {\n        \"name\": \"encoded\",\n        \"type\": \"bytes\"\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre>"},{"location":"primitive_types/#examples-with-null","title":"Examples with <code>null</code>","text":"<pre><code>import dataclasses\nfrom typing import Optional\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: Optional[str] = None\n    age: Optional[int] = None\n    height: Optional[types.Float32] = None\n    weight: Optional[types.Int32] = None\n    is_student: Optional[bool] = None\n    money_available: Optional[float] = None\n    encoded: Optional[bytes] = None\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": [\"null\", \"string\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"age\",\n      \"type\": [\"null\", \"long\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"height\",\n      \"type\": [\"null\", \"float\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": [\"null\", \"int\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": [\"null\", \"boolean\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": [\"null\", \"double\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"encoded\",\n      \"type\": [\"null\", \"bytes\"],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"primitive_types/#examples-with-default-values","title":"Examples with default values","text":"<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = 'Juan'\n    age: int = 20\n    height: types.Float32 = 165.3\n    weight: types.Int32 = 72\n    is_student: bool = True\n    money_available: float = 100.2\n    encoded: bytes = b\"hi\"\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\",\n      \"default\": \"Juan\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"height\",\n      \"type\": [\"null\", \"float\"],\n      \"default\": 165.3\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": [\"null\", \"int\"],\n      \"default\": 72\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": \"boolean\",\n      \"default\": true\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": \"double\",\n      \"default\": 100.2\n    },\n    {\n        \"name\": \"encoded\",\n        \"type\": \"bytes\",\n        \"default\": \"hi\"\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic/","title":"Pydantic Integration","text":"<p>It is possible to use pydantic with <code>dataclasses-avroschema</code> making use of <code>AvroBaseModel</code>:</p> <p>You must use use all the <code>pydantic</code> features and all <code>dataclasses-avroschema</code> functionality will be injected.</p> <p>Note</p> <p>With <code>pydantic</code> you do not have to use <code>python dataclasses</code></p>"},{"location":"pydantic/#avro-and-json-schemas","title":"Avro and Json schemas","text":"Basic usage<pre><code>import typing\nimport enum\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\nfrom pydantic import Field\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\nclass UserAdvance(AvroBaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        schema_doc = False\n\n\n# Avro schema\nUserAdvance.avro_schema()\n'{\n    \"type\": \"record\",\n    \"name\": \"UserAdvance\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}, \"default\": [\"dog\", \"cat\"]},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}, \"default\": {\"key\": 1}},\n        {\"name\": \"has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"favorite_colors\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}, \"default\": \"BLUE\"},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\n# Json schema\nUserAdvance.model_json_schema()\n\n{\n    'required': ['name', 'age'],\n    'title': 'UserAdvance',\n    'type': 'object'\n    'properties': {\n        'name': {'title': 'Name', 'type': 'string'},\n        'age': {'title': 'Age', 'type': 'integer'},\n        'pets': {'items': {'type': 'string'}, 'title': 'Pets', 'type': 'array'},\n        'accounts': {'additionalProperties': {'type': 'integer'}, 'title': 'Accounts', 'type': 'object'},\n        'has_car': {'default': False, 'title': 'Has Car', 'type': 'boolean'},\n        'favorite_colors': {'allOf': [{'$ref': '#/$defs/FavoriteColor'}], 'default': 'BLUE'},\n        'country': {'default': 'Argentina', 'title': 'Country', 'type': 'string'},\n        'address': {'default': None, 'title': 'Address', 'type': 'string'}\n    },\n    '$defs': {'FavoriteColor': {'enum': ['BLUE', 'YELLOW', 'GREEN'], 'title': 'FavoriteColor', 'type': 'string'}},\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>You must use pydantic.Field instead of dataclasses.field</p>"},{"location":"pydantic/#avro-schemas-with-pydantic-types","title":"Avro schemas with pydantic types","text":"<p>Most of <code>pydantic</code> types are supported and from them it is possible to generate <code>avro fields</code>. Because <code>pydantic</code> types are not native <code>python types</code> the end result will contain extra metadata so the end users will have more context at the moment of using the schema. The extra <code>metadata</code> is specified using the key <code>pydantic-class</code>.</p>"},{"location":"pydantic/#supported-fields","title":"Supported fields","text":"Avro Type Pydantic Type string pydantic.FilePath string pydantic.DirectoryPath string pydantic.EmailStr string pydantic.NameEmail string pydantic.AnyUrl string pydantic.AnyHttpUrl string pydantic.HttpUrl string pydantic.FileUrl string pydantic.PostgresDsn string pydantic.CockroachDsn string pydantic.AmqpDsn string pydantic.RedisDsn string pydantic.MongoDsn string pydantic.KafkaDsn string pydantic.SecretStr string pydantic.IPvAnyAddress string pydantic.IPvAnyInterface string pydantic.IPvAnyNetwork double pydantic.NegativeFloat double pydantic.PositiveFloat long pydantic.NegativeInt long pydantic.PositiveIntstr Avro Type Logical type Pydantic Type string uuid pydantic.UUID1 string uuid pydantic.UUID3 string uuid pydantic.UUID4 string uuid pydantic.UUID5 int date pydantic.PastDate int date pydantic.FutureDate long timestamp-millis pydantic.PastDatetime long timestamp-millis pydantic.FutureDatetime long timestamp-millis pydantic.AwareDatetime long timestamp-millis pydantic.NaiveDatetime <pre><code>import pydantic\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass Infrastructure(AvroBaseModel):\n    email: pydantic.EmailStr\n    postgres_dsn: pydantic.PostgresDsn\n    cockroach_dsn: pydantic.CockroachDsn\n    amqp_dsn: pydantic.AmqpDsn\n    redis_dsn: pydantic.RedisDsn\n    mongo_dsn: pydantic.MongoDsn\n    kafka_url: pydantic.KafkaDsn\n    total_nodes: pydantic.PositiveInt\n\n\nInfrastructure.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"Infrastructure\",\n    \"fields\": [\n        {\"name\": \"email\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"EmailStr\"}},\n        {\"name\": \"postgres_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"PostgresDsn\"}},\n        {\"name\": \"cockroach_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"CockroachDsn\"}},\n        {\"name\": \"amqp_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"AmqpDsn\"}},\n        {\"name\": \"redis_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"RedisDsn\"}},\n        {\"name\": \"mongo_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"MongoDsn\"}},\n        {\"name\": \"kafka_url\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}},\n        {\"name\": \"total_nodes\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}}\n    ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>The key <code>pydantic-class</code> has been added as <code>metadata</code> to have more context when using the schema</p>"},{"location":"pydantic/#model-generation","title":"Model generation","text":"<p>If is possible to generate pydantic models when <code>pydantic types</code> have been used. If a field has the matadata key <code>pydantic-class</code> then the proper pydantic types will be used.</p> <p>Schema example:</p> <pre><code>from dataclasses_avroschema import ModelGenerator, ModelType\n\nmodel_generator = ModelGenerator()\n\nschema = {\n    \"type\": \"record\",\n    \"name\": \"Infrastructure\",\n    \"fields\": [\n        {\"name\": \"email\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"EmailStr\"}},\n        {\"name\": \"kafka_url\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}},\n        {\"name\": \"total_nodes\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}},\n        {\"name\": \"event_id\", \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\", \"pydantic-class\": \"UUID1\"}},\n        {\"name\": \"landing_zone_nodes\", \"type\": {\"type\": \"array\", \"items\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}, \"name\": \"landing_zone_node\"}},\n        {\"name\": \"total_nodes_in_aws\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}, \"default\": 10},\n        {\"name\": \"optional_kafka_url\", \"type\": [\"null\", {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}], \"default\": None}\n    ]\n}\n\nresult = model_generator.render(schema=schema, model_type=ModelType.AVRODANTIC.value)\n\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>and then render the result:</p> <pre><code>from dataclasses_avroschema.pydantic import AvroBaseModel\nimport typing\nimport pydantic\n\n\nclass Infrastructure(AvroBaseModel):\n    email: pydantic.EmailStr\n    kafka_url: pydantic.KafkaDsn\n    total_nodes: pydantic.PositiveInt\n    event_id: pydantic.UUID1\n    landing_zone_nodes: typing.List[pydantic.PositiveInt]\n    total_nodes_in_aws: pydantic.PositiveInt = 10\n    optional_kafka_url: typing.Optional[pydantic.KafkaDsn] = None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>In order to render the pydantic types the base class must be <code>AVRO_BASE_MODEL</code> or <code>PYDANTIC_MODEL</code></p>"},{"location":"pydantic/#mapping-avro-fields-to-pydantic-types","title":"Mapping <code>avro fields</code> to <code>pydantic types</code>","text":"Avro Type Metadata Pydantic Type string \"pydantic-class\": \"DirectoryPath\" pydantic.FilePath string \"pydantic-class\": \"DirectoryPath\" pydantic.DirectoryPath string \"pydantic-class\": \"EmailStr\" pydantic.EmailStr string \"pydantic-class\": \"NameEmail\" pydantic.NameEmail string \"pydantic-class\": \"AnyUrl\" pydantic.AnyUrl string \"pydantic-class\": \"AnyHttpUrl\" pydantic.AnyHttpUrl string \"pydantic-class\": \"HttpUrl\" pydantic.HttpUrl string \"pydantic-class\": \"FileUrl\" pydantic.FileUrl string \"pydantic-class\": \"PostgresDsn\" pydantic.PostgresDsn string \"pydantic-class\": \"CockroachDsn pydantic.CockroachDsn string \"pydantic-class\": \"AmqpDsn\" pydantic.AmqpDsn string \"pydantic-class\": \"RedisDsn\" pydantic.RedisDsn string \"pydantic-class\": \"MongoDsn\" pydantic.MongoDsn string \"pydantic-class\": \"KafkaDsn\" pydantic.KafkaDsn string \"pydantic-class\": \"SecretStr\" pydantic.SecretStr string \"pydantic-class\": \"IPvAnyAddress\" pydantic.IPvAnyAddress string \"pydantic-class\": \"IPvAnyInterface\" pydantic.IPvAnyInterface string \"pydantic-class\": \"IPvAnyNetwork\" pydantic.IPvAnyNetwork double \"pydantic-class\": \"NegativeFloat\" pydantic.NegativeFloat double \"pydantic-class\": \"PositiveFloat\" pydantic.PositiveFloat long \"pydantic-class\": \"NegativeInt\" pydantic.NegativeInt long \"pydantic-class\": \"PositiveInt\" pydantic.PositiveInt Avro Type Logical Type Metadata Pydantic Type string uuid \"pydantic-class\": \"UUID1\" pydantic.UUID1 string uuid \"pydantic-class\": \"UUID3\" pydantic.UUID3 string uuid \"pydantic-class\": \"UUID4\" pydantic.UUID4 string uuid \"pydantic-class\": \"UUID5\" pydantic.UUID5"},{"location":"pydantic/#pydantic-and-dataclasses_avroschema-batteries","title":"Pydantic and dataclasses_avroschema batteries","text":""},{"location":"pydantic/#to-dict-to-json-and-serialization","title":"To dict, to json and serialization","text":"getting dict and json<pre><code>user = UserAdvance(name=\"bond\", age=50)\n\n# to_json from dataclasses-avroschema is the same that json from pydantic\nassert user.to_json(separators=(\",\",\":\",)) == user.model_dump_json()\n\n# to_dict from dataclasses-avroschema is the same that dict from pydantic\nassert user.to_dict() == user.model_dump()\n</code></pre> serialization<pre><code>event = user.serialize()\nprint(event)\n# &gt;&gt;&gt; b'\\x08bondd\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x00\\x12Argentina\\x00'\n\nUserAdvance.deserialize(data=event)\n# &gt;&gt;&gt; UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=&lt;FavoriteColor.BLUE: 'BLUE'&gt;, country='Argentina', address=None)\n</code></pre>"},{"location":"pydantic/#parsing-objects","title":"Parsing Objects","text":"parse_obj usage<pre><code>import typing\n\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass Address(AvroBaseModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [{\n        \"street\": \"test\",\n        \"street_number\": 10,\n        }],\n    }\n\nuser = User.parse_obj(data=data_user)\nassert type(user.addresses[0]) is Address\n</code></pre> <p>Note</p> <p>The method <code>parse_obj</code> is defined by <code>dataclasses_avroschemas</code> which internally is calling <code>model_validate</code> (introduced in pydantic v2)</p> <p>(This script is complete, it should run \"as is\")</p> validate_python usage<pre><code>from typing import List\n\nfrom pydantic import TypeAdapter\n\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n\n\ndata = [{\"name\": \"bond\", \"age\": 50}, {\"name\": \"bond2\", \"age\": 60}]\nUserListValidator = TypeAdapter(List[User])\nusers = UserListValidator.validate_python(data)\n\nusers[0].avro_schema()\n# '{\"type\": \"record\", \"name\": \"User\", \"fields\": [{\"name\": \"name\", \"type\": \"string\"}, {\"name\": \"age\", \"type\": \"long\"}], \"doc\": \"User with multiple Address\"}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic/#fake","title":"Fake","text":"<p>It is also possible to create <code>fake</code> instances with <code>pydantic</code> models:</p> <pre><code>import typing\nimport datetime\nfrom pydantic import Field\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    birthday: datetime.date\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n\nprint(User.fake())\n# &gt;&gt;&gt; User(name='qWTLkqcIVmSBxpWMpFyR', age=2608, birthday=datetime.date(1982, 3, 30), pets=['wqoEXcJRYjcnJmnIvtiI'], accounts={'JueNdHdzIhHIDsjlHJLc': 779}, has_car=True)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>All pydantic supported fields can be used with fake</p>"},{"location":"pydantic/#excluding-fields","title":"Excluding fields","text":"<p>Pydantic Fields can be excluded when <code>dict</code>, <code>json</code> or <code>copy</code> methods are called. This meaans that the exclusion is only for exporting models but not excluded in the instance creations, then the <code>avro serialization</code> will include all the class attributes.</p> <pre><code>import typing\nfrom pydantic import Field\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"], exclude=True)\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1}, exclude=True)\n    has_car: bool = False\n\nuser = User(name=\"bond\", age=50, has_car=True)\nprint(user)\n# &gt;&gt;&gt; User(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=True)\n\nprint(user.model_dump())\n# &gt;&gt;&gt; {'name': 'bond', 'age': 50, 'has_car': True} Excludes pets and accounts !!!\n\nevent = user.serialize()\nassert user == User.deserialize(event)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic/#model-config","title":"Model Config","text":"<p>With <code>AvroBaseModel</code> you can use the same Model Config that <code>pydantic</code> provides, for example:</p> Not use Enum valuesUse Enum values <pre><code>import enum\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\nclass Color(str, enum.Enum):\n    BLUE = \"BLUE\"\n    RED = \"RED\"\n\n\nclass Bus(AvroBaseModel):\n    driver: str\n    color: Color\n\nbus =  Bus(driver=\"bond\", color=Color.RED)\nprint(bus.dict())\n# &gt;&gt;&gt; {'driver': 'bond', 'color': &lt;Color.RED: 'RED'&gt;}\n</code></pre> <pre><code>import enum\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\nfrom pydantic import ConfigDict\n\n\nclass Color(str, enum.Enum):\n    BLUE = \"BLUE\"\n    RED = \"RED\"\n\n\nclass Bus(AvroBaseModel):\n    model_config = ConfigDict(use_enum_values=True)\n    driver: str\n    color: Color\n\nbus =  Bus(driver=\"bond\", color=Color.RED)\nprint(busmodel_dump())\n# &gt;&gt;&gt; {'driver': 'bond', 'color': 'RED'}\n</code></pre>"},{"location":"pydantic/#adding-custom-field-level-attributes","title":"Adding Custom Field-level Attributes","text":"<p>To add <code>custom field attributes</code> the <code>metadata</code> attribute must be set in <code>pydantic.Field</code>. For more info check adding-custom-field-level-attributes section for <code>dataclasses</code>.</p> <p>Note</p> <p>Make sure that <code>pydantic.Field</code> is used and NOT <code>dataclasses.field</code></p>"},{"location":"pydantic/#custom-data-types-as-fields","title":"Custom Data Types as Fields","text":"<p>If needed, you can annotate fields with custom classes that define validators.</p>"},{"location":"pydantic/#classes-with-__get_pydantic_core_schema__","title":"Classes with <code>__get_pydantic_core_schema__</code>","text":"<p>Note</p> <p>The conversion mapping of a custom class to its supported type must be defined in the model's <code>json_encoders</code> config.</p> <p>Warning</p> <p>Generating models from avro schemas that were generated by classes containing Custom Class fields is not supported.</p> <pre><code>from typing import Any\n\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\nfrom pydantic import ConfigDict, GetCoreSchemaHandler\nfrom pydantic_core import core_schema\n\n\nclass CustomClass:\n    def __init__(self, value: str) -&gt; None:\n        self.value = value\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler):\n        def validate(value):\n            if isinstance(value, CustomClass):\n                return value\n            elif not isinstance(value, str):\n                raise ValueError(f\"Value must be a string or CustomClass - not {type(value)}\")\n\n            return cls(value)\n\n        from_str_schema = core_schema.chain_schema(\n            [\n                core_schema.str_schema(),\n                core_schema.no_info_plain_validator_function(validate),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_str_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # check if it's an instance first before doing any further work\n                    core_schema.is_instance_schema(CustomClass),\n                    from_str_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(lambda instance: instance.x),\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{self.value}\"\n\n\nclass MyModel(AvroBaseModel):\n    model_config = ConfigDict(json_encoders={CustomClass: str}, arbitrary_types_allowed=True)\n    my_id: CustomClass\n\n\nprint(MyModel.avro_schema_to_python())\n\"\"\"\n{\n  \"type\": \"record\",\n  \"name\": \"MyModel\",\n  \"fields\": [\n    {\n      \"name\": \"my_id\",\n      \"type\": \"string\"\n    }\n  ]\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic_v1/","title":"Pydantic V1 Integration","text":"<p>It is possible to use pydantic with <code>dataclasses-avroschema</code> making use of <code>AvroBaseModel</code>:</p> <p>You must use use all the <code>pydantic</code> features and all <code>dataclasses-avroschema</code> functionality will be injected.</p> <p>Note</p> <p>With <code>pydantic</code> you do not have to use <code>python dataclasses</code></p> <p>Warning</p> <p>The support of <code>pydantic v1</code> will be deprecated in the future. We recommend to migrate to <code>pydantic v2</code>.</p>"},{"location":"pydantic_v1/#avro-and-json-schemas","title":"Avro and Json schemas","text":"Basic usage<pre><code>import typing\nimport enum\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\nfrom pydantic.v1 import Field\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\nclass UserAdvance(AvroBaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        schema_doc = False\n\n\n# Avro schema\nUserAdvance.avro_schema()\n'{\n    \"type\": \"record\",\n    \"name\": \"UserAdvance\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}, \"default\": [\"dog\", \"cat\"]},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}, \"default\": {\"key\": 1}},\n        {\"name\": \"has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"favorite_colors\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}, \"default\": \"BLUE\"},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\n# Json schema\nUserAdvance.json_schema()\n\n'{\n    \"title\": \"UserAdvance\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n        \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n        \"pets\": {\"title\": \"Pets\", \"type\": \"array\", \"items\": {\"type\": \"string\"}},\n        \"accounts\": {\"title\": \"Accounts\", \"type\": \"object\", \"additionalProperties\": {\"type\": \"integer\"}},\n        \"has_car\": {\"title\": \"Has Car\", \"default\": false, \"type\": \"boolean\"},\n        \"favorite_colors\": {\"default\": \"BLUE\", \"allOf\": [{\"$ref\": \"#/definitions/FavoriteColor\"}]},\n        \"country\": {\"title\": \"Country\", \"default\": \"Argentina\", \"type\": \"string\"},\n        \"address\": {\"title\": \"Address\", \"type\": \"string\"}},\n        \"required\": [\"name\", \"age\"], \"definitions\": {\"FavoriteColor\": {\"title\": \"FavoriteColor\", \"description\": \"An enumeration.\", \"enum\": [\"BLUE\", \"YELLOW\", \"GREEN\"], \"type\": \"string\"}}}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>You must use pydantic.Field instead of dataclasses.field</p>"},{"location":"pydantic_v1/#avro-schemas-with-pydantic-types","title":"Avro schemas with pydantic types","text":"<p>Most of <code>pydantic</code> types are supported and from them it is possible to generate <code>avro fields</code>. Because <code>pydantic</code> types are not native <code>python types</code> the end result will contain extra metadata so the end users will have more context at the moment of using the schema. The extra <code>metadata</code> is specified using the key <code>pydantic-class</code>.</p>"},{"location":"pydantic_v1/#supported-fields","title":"Supported fields","text":"Avro Type Pydantic Type string pydantic.FilePath string pydantic.DirectoryPath string pydantic.EmailStr string pydantic.NameEmail string pydantic.AnyUrl string pydantic.AnyHttpUrl string pydantic.HttpUrl string pydantic.FileUrl string pydantic.PostgresDsn string pydantic.CockroachDsn string pydantic.AmqpDsn string pydantic.RedisDsn string pydantic.MongoDsn string pydantic.KafkaDsn string pydantic.SecretStr string pydantic.IPvAnyAddress string pydantic.IPvAnyInterface string pydantic.IPvAnyNetwork double pydantic.NegativeFloat double pydantic.PositiveFloat long pydantic.NegativeInt long pydantic.PositiveIntstr long pydantic.ConstrainedInt (conint) Avro Type Logical type Pydantic Type string uuid pydantic.UUID1 string uuid pydantic.UUID3 string uuid pydantic.UUID4 string uuid pydantic.UUID5 <pre><code>from pydantic import v1 as pydantic\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass Infrastructure(AvroBaseModel):\n    email: pydantic.EmailStr\n    postgres_dsn: pydantic.PostgresDsn\n    cockroach_dsn: pydantic.CockroachDsn\n    amqp_dsn: pydantic.AmqpDsn\n    redis_dsn: pydantic.RedisDsn\n    mongo_dsn: pydantic.MongoDsn\n    kafka_url: pydantic.KafkaDsn\n    total_nodes: pydantic.PositiveInt\n\n\nInfrastructure.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"Infrastructure\",\n    \"fields\": [\n        {\"name\": \"email\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"EmailStr\"}},\n        {\"name\": \"postgres_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"PostgresDsn\"}},\n        {\"name\": \"cockroach_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"CockroachDsn\"}},\n        {\"name\": \"amqp_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"AmqpDsn\"}},\n        {\"name\": \"redis_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"RedisDsn\"}},\n        {\"name\": \"mongo_dsn\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"MongoDsn\"}},\n        {\"name\": \"kafka_url\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}},\n        {\"name\": \"total_nodes\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}}\n    ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>The key <code>pydantic-class</code> has been added as <code>metadata</code> to have more context when using the schema</p>"},{"location":"pydantic_v1/#model-generation","title":"Model generation","text":"<p>If is possible to generate pydantic models when <code>pydantic types</code> have been used. If a field has the matadata key <code>pydantic-class</code> then the proper pydantic types will be used.</p> <p>Schema example:</p> <pre><code>from dataclasses_avroschema import ModelGenerator, BaseClassEnum\n\nmodel_generator = ModelGenerator(base_class=BaseClassEnum.AVRO_DANTIC_MODEL.value)\n\nschema = {\n    \"type\": \"record\",\n    \"name\": \"Infrastructure\",\n    \"fields\": [\n        {\"name\": \"email\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"EmailStr\"}},\n        {\"name\": \"kafka_url\", \"type\": {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}},\n        {\"name\": \"total_nodes\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}},\n        {\"name\": \"event_id\", \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\", \"pydantic-class\": \"UUID1\"}},\n        {\"name\": \"landing_zone_nodes\", \"type\": {\"type\": \"array\", \"items\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}, \"name\": \"landing_zone_node\"}},\n        {\"name\": \"total_nodes_in_aws\", \"type\": {\"type\": \"long\", \"pydantic-class\": \"PositiveInt\"}, \"default\": 10},\n        {\"name\": \"optional_kafka_url\", \"type\": [\"null\", {\"type\": \"string\", \"pydantic-class\": \"KafkaDsn\"}], \"default\": None}\n    ]\n}\n\nresult = model_generator.render(schema=schema)\n\nwith open(\"models.py\", mode=\"+w\") as f:\n    f.write(result)\n</code></pre> <p>and then render the result:</p> <pre><code>from dataclasses_avroschema.pydantic.v1 import AvroBaseModel\nfrom pydantic import v1 as pydantic\nimport typing\n\n\nclass Infrastructure(AvroBaseModel):\n    email: pydantic.EmailStr\n    kafka_url: pydantic.KafkaDsn\n    total_nodes: pydantic.PositiveInt\n    event_id: pydantic.UUID1\n    landing_zone_nodes: typing.List[pydantic.PositiveInt]\n    total_nodes_in_aws: pydantic.PositiveInt = 10\n    optional_kafka_url: typing.Optional[pydantic.KafkaDsn] = None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>In order to render the pydantic types the base class must be <code>AVRO_BASE_MODEL</code> or <code>PYDANTIC_MODEL</code></p>"},{"location":"pydantic_v1/#mapping-avro-fields-to-pydantic-types","title":"Mapping <code>avro fields</code> to <code>pydantic types</code>","text":"Avro Type Metadata Pydantic Type string \"pydantic-class\": \"DirectoryPath\" pydantic.FilePath string \"pydantic-class\": \"DirectoryPath\" pydantic.DirectoryPath string \"pydantic-class\": \"EmailStr\" pydantic.EmailStr string \"pydantic-class\": \"NameEmail\" pydantic.NameEmail string \"pydantic-class\": \"AnyUrl\" pydantic.AnyUrl string \"pydantic-class\": \"AnyHttpUrl\" pydantic.AnyHttpUrl string \"pydantic-class\": \"HttpUrl\" pydantic.HttpUrl string \"pydantic-class\": \"FileUrl\" pydantic.FileUrl string \"pydantic-class\": \"PostgresDsn\" pydantic.PostgresDsn string \"pydantic-class\": \"CockroachDsn pydantic.CockroachDsn string \"pydantic-class\": \"AmqpDsn\" pydantic.AmqpDsn string \"pydantic-class\": \"RedisDsn\" pydantic.RedisDsn string \"pydantic-class\": \"MongoDsn\" pydantic.MongoDsn string \"pydantic-class\": \"KafkaDsn\" pydantic.KafkaDsn string \"pydantic-class\": \"SecretStr\" pydantic.SecretStr string \"pydantic-class\": \"IPvAnyAddress\" pydantic.IPvAnyAddress string \"pydantic-class\": \"IPvAnyInterface\" pydantic.IPvAnyInterface string \"pydantic-class\": \"IPvAnyNetwork\" pydantic.IPvAnyNetwork double \"pydantic-class\": \"NegativeFloat\" pydantic.NegativeFloat double \"pydantic-class\": \"PositiveFloat\" pydantic.PositiveFloat long \"pydantic-class\": \"NegativeInt\" pydantic.NegativeInt long \"pydantic-class\": \"PositiveInt\" pydantic.PositiveInt long \"pydantic-class\": ConstrainedInt\" pydantic.ConstrainedInt Avro Type Logical Type Metadata Pydantic Type string uuid \"pydantic-class\": \"UUID1\" pydantic.UUID1 string uuid \"pydantic-class\": \"UUID3\" pydantic.UUID3 string uuid \"pydantic-class\": \"UUID4\" pydantic.UUID4 string uuid \"pydantic-class\": \"UUID5\" pydantic.UUID5"},{"location":"pydantic_v1/#pydantic-and-dataclasses_avroschema-batteries","title":"Pydantic and dataclasses_avroschema batteries","text":""},{"location":"pydantic_v1/#to-dict-to-json-and-serialization","title":"To dict, to json and serialization","text":"getting dict and json<pre><code>user = UserAdvance(name=\"bond\", age=50)\n\n# to_json from dataclasses-avroschema is the same that json from pydantic\nassert user.to_json() == user.json()\n\n# to_dict from dataclasses-avroschema is the same that dict from pydantic\nassert user.to_dict() == user.dict()\n</code></pre> serialization<pre><code>event = user.serialize()\nprint(event)\n# &gt;&gt;&gt; b'\\x08bondd\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x00\\x12Argentina\\x00'\n\nUserAdvance.deserialize(data=event)\n# &gt;&gt;&gt; UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=&lt;FavoriteColor.BLUE: 'BLUE'&gt;, country='Argentina', address=None)\n</code></pre>"},{"location":"pydantic_v1/#parsing-objects","title":"Parsing Objects","text":"parse_obj usage<pre><code>import typing\n\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass Address(AvroBaseModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [{\n        \"street\": \"test\",\n        \"street_number\": 10,\n        }],\n    }\n\nuser = User.parse_obj(data=data_user)\nassert type(user.addresses[0]) is Address\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> parse_obj_as usage<pre><code>from typing import List\n\nfrom pydantic import parse_obj_as\n\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n\n\ndata = [{\"name\": \"bond\", \"age\": 50}, {\"name\": \"bond2\", \"age\": 60}]\nusers = parse_obj_as(List[User], data)\n\nusers[0].avro_schema()\n# '{\"type\": \"record\", \"name\": \"User\", \"fields\": [{\"name\": \"name\", \"type\": \"string\"}, {\"name\": \"age\", \"type\": \"long\"}], \"doc\": \"User with multiple Address\"}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic_v1/#fake","title":"Fake","text":"<p>It is also possible to create <code>fake</code> instances with <code>pydantic</code> models:</p> <pre><code>import typing\nimport datetime\nfrom pydantic.v1 import Field\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    birthday: datetime.date\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n\nprint(User.fake())\n# &gt;&gt;&gt; User(name='qWTLkqcIVmSBxpWMpFyR', age=2608, birthday=datetime.date(1982, 3, 30), pets=['wqoEXcJRYjcnJmnIvtiI'], accounts={'JueNdHdzIhHIDsjlHJLc': 779}, has_car=True)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>All pydantic supported fields can be used with fake</p>"},{"location":"pydantic_v1/#excluding-fields","title":"Excluding fields","text":"<p>Pydantic Fields can be excluded when <code>dict</code>, <code>json</code> or <code>copy</code> methods are called. This meaans that the exclusion is only for exporting models but not excluded in the instance creations, then the <code>avro serialization</code> will include all the class attributes.</p> <pre><code>import typing\nfrom pydantic.v1 import Field\nfrom dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"], exclude=True)\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1}, exclude=True)\n    has_car: bool = False\n\nuser = User(name=\"bond\", age=50, has_car=True)\nprint(user)\n# &gt;&gt;&gt; User(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=True)\n\nprint(user.dict())\n# &gt;&gt;&gt; {'name': 'bond', 'age': 50, 'has_car': True} Excludes pets and accounts !!!\n\nevent = user.serialize()\nassert user == User.deserialize(event)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic_v1/#model-config","title":"Model Config","text":"<p>With <code>AvroBaseModel</code> you can use the same Model Config that <code>pydantic</code> provides, for example:</p> Not use Enum valuesUse Enum values <pre><code>import enum\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\nclass Color(str, enum.Enum):\n    BLUE = \"BLUE\"\n    RED = \"RED\"\n\n\nclass Bus(AvroBaseModel):\n    driver: str\n    color: Color\n\nbus =  Bus(driver=\"bond\", color=Color.RED)\nprint(bus.dict())\n# &gt;&gt;&gt; {'driver': 'bond', 'color': &lt;Color.RED: 'RED'&gt;}\n</code></pre> <pre><code>import enum\nfrom dataclasses_avroschema.pydantic import AvroBaseModel\n\nclass Color(str, enum.Enum):\n    BLUE = \"BLUE\"\n    RED = \"RED\"\n\n\nclass Bus(AvroBaseModel):\n    driver: str\n    color: Color\n\n    class Config:\n        use_enum_values = True\n\nbus =  Bus(driver=\"bond\", color=Color.RED)\nprint(bus.dict())\n# &gt;&gt;&gt; {'driver': 'bond', 'color': 'RED'}\n</code></pre>"},{"location":"pydantic_v1/#adding-custom-field-level-attributes","title":"Adding Custom Field-level Attributes","text":"<p>To add <code>custom field attributes</code> the <code>metadata</code> attribute must be set in <code>pydantic.Field</code>. For more info check adding-custom-field-level-attributes section for <code>dataclasses</code>.</p> <p>Note</p> <p>Make sure that <code>pydantic.Field</code> is used and NOT <code>dataclasses.field</code></p>"},{"location":"pydantic_v1/#custom-data-types-as-fields","title":"Custom Data Types as Fields","text":"<p>If needed, you can annotate fields with custom classes that define validators.</p>"},{"location":"pydantic_v1/#classes-with-__get_validators__","title":"Classes with <code>__get_validators__</code>","text":"<p>These classes are defined by pydantic as Python classes that define the <code>validate</code> and <code>__get_validators__</code> methods.</p> <p>Note</p> <p>The conversion mapping of a custom class to its supported type must be defined in the model's <code>json_encoders</code> config.</p> <p>Warning</p> <p>Generating models from avro schemas that were generated by classes containing Custom Class fields is not supported.</p> <pre><code>from dataclasses_avroschema.pydantic.v1 import AvroBaseModel\n\n\nclass CustomClass:\n    def __init__(self, value: str) -&gt; None:\n        self.value = value\n\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value):\n        if isinstance(value, CustomClass):\n            return value\n        elif not isinstance(value, str):\n            raise ValueError(f\"Value must be a string or CustomClass - not {type(value)}\")\n\n        return cls(value)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.value}\"\n\n\nclass MyModel(AvroBaseModel):\n    my_id: CustomClass\n\n    class Config:\n        json_encoders = {CustomClass: str}\n\n\nprint(MyModel.avro_schema_to_python())\n\"\"\"\n{\n  \"type\": \"record\",\n  \"name\": \"MyModel\",\n  \"fields\": [\n    {\n      \"name\": \"my_id\",\n      \"type\": \"string\"\n    }\n  ]\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/","title":"Records","text":"<p>Mapped as a Python class. There are some special avro attributes like <code>aliases</code>, <code>namespace</code> and <code>doc</code> (both not required) that can be specified in a record type.</p> <p>The <code>doc</code> attribute can be set via the docstring class. The <code>aliases</code> and <code>namespaces</code> must be set using <code>Class Meta</code>.</p>"},{"location":"records/#basic-usage","title":"Basic usage","text":"<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        namespace = \"test.com.ar/user/v1\"\n        aliases = [\"User\", \"My favorite User\"]\n\nUser.avro_schema()\n\n\"\"\"{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": false},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3}\n  ],\n  \"doc\": \"My User Class\",\n  \"namespace\": \"test.com.ar/user/v1\",\n  \"aliases\": [\"User\", \"My favorite User\"]\n}\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#class-meta","title":"Class Meta","text":"<p>The <code>class Meta</code> is used to specify schema attributes that are not represented by the class fields like <code>namespace</code>, <code>aliases</code> and whether to include the <code>schema documentation</code>. Also custom schema name (the default is the class' name) via <code>schema_name</code> attribute, <code>alias_nested_items</code> when you have nested items and you want to use custom naming for them, <code>custom dacite</code> configuration can be provided, <code>field_order</code>, <code>exclude</code> and <code>convert_literal_to_enum</code>.</p> Class Meta description<pre><code>class Meta:\n    schema_name = \"Name other than the class name\"\n    schema_doc = False\n    namespace = \"test.com.ar/user/v1\"\n    aliases = [\"User\", \"My favorite User\"]\n    alias_nested_items = {\"address\": \"Address\"}\n    field_order = [\"age\", \"name\",]\n    exclude = [\"last_name\",]\n    convert_literal_to_enum = False\n    dacite_config = {\n        \"strict_unions_match\": True,\n        \"strict\": True,\n    }\n</code></pre> <p><code>schema_doc Union[boolean, str]</code>: Whether include the <code>schema documentation</code> generated from <code>docstrings</code>. Default <code>True</code>. If the value is a <code>string</code> if will be used to generate the schema documentation.</p> <p><code>namespace Optional[str]</code>: Schema namespace. Default <code>None</code></p> <p><code>aliases Optional[List[str]]</code>: Schema aliases. Default <code>None</code></p> <p><code>alias_nested_items Optional[Dict[str, str]]</code>: Nested items names</p> <p><code>field_order Optional[List[str]]</code>: List of field names to specify their order to the output schema</p> <p><code>exclude Optional[List[str]]</code>: List of field names to be excluded in the output schema</p> <p><code>convert_literal_to_enum Optional[bool]</code>: Whether convert <code>Literal string</code> to <code>enum</code></p> <p><code>dacite_config Optional[Dict]</code>: Dacite custom config</p>"},{"location":"records/#record-to-json-and-dict","title":"Record to json and dict","text":"<p>You can get the <code>json</code> and <code>dict</code> representation of your instance using <code>to_json</code> and <code>to_dict</code> methods:</p> Json and Dict example<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n\nuser = User(name=\"Bond\", age=50)\n\nuser.to_json()\n# &gt;&gt;&gt; '{\"name\": \"Bond\", \"age\": 50, \"has_pets\": false, \"money\": 100.3}'\n\nuser.to_dict()\n# &gt;&gt;&gt; {'name': 'Bond', 'age': 50, 'has_pets': False, 'money': 100.3}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#parsing-objects","title":"Parsing objects","text":"<p>It is possible to create <code>python instances</code> from a <code>dictionary</code> using the <code>parse_obj</code> method. If you are familiar with <code>pydantic</code>, this functionality does the same. Under the hood <code>dataclasses-avroschema</code> uses dacite with a default configuration:</p> <pre><code>\"check_types\": False,\n\"forward_references\": {\n    Model.__name__: Model,\n},\n</code></pre> <p>where <code>Model</code> is the model that you have defined in your code</p> Usage<pre><code>import typing\nfrom dataclasses import dataclass\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Bus(AvroModel):\n    driver: str\n    total: int\n\ndata = {\"driver\": \"Marcos\", \"total\": 10}\nbus = Bus.parse_obj(data=data)\n\nprint(bus)\n# &gt;&gt;&gt;&gt; Bus(driver='Marcos', total=10)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>There are some use cases where a custom dacite config is needed, so you can provide one using the <code>dacite_config</code> in the <code>class Meta</code></p>"},{"location":"records/#validation","title":"Validation","text":"<p>Python classes that inheritance from <code>AvroModel</code> has a <code>validate</code> method. This method <code>validates</code> whether the instance data matches the schema that it represents, for example:</p> Validation example<pre><code>from dataclasses import dataclass\n\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n# this creates a proper instance\nuser_instance = User(\n    name=\"a name\",\n    age=10,\n    has_pets=True,\n    money=0,\n    encoded=b'hi',\n)\nassert user_instance.validate()\n\n# set 1 to the name attribute and the fastavro validation should fail\n# This is possible because in dataclasses there is not restriction,\n# but at the moment of using pydantic this will change\nuser_instance.name = 1\nwith pytest.raises(ValidationError) as exc:\n    assert user_instance.validate()\n\nassert json.loads(str(exc.value)) == [\"User.name is &lt;1&gt; of type &lt;class 'int'&gt; expected string\"]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#nested-schema-resolution-directly-from-dictionaries","title":"Nested schema resolution directly from dictionaries","text":"<p>Sometimes you have a <code>dictionary</code> and you want to create an instance without creating the nested objects. This library follows the same approach as <code>pydantic</code> with <code>parse_obj</code> method. This is also valid for <code>pydantic.AvroBaseModel</code>.</p> <pre><code>from dataclasses import dataclass\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n@dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [{\n        \"street\": \"test\",\n        \"street_number\": 10,\n        }],\n    }\n\nuser = User.parse_obj(data=data_user)\nassert type(user.addresses[0]) is Address\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#class-inheritance","title":"Class inheritance","text":"<p>It is possible to have inheritance so you do not have to repeat the same code. You need to be aware that parent classes might have attributes with default values and that can cause <code>TypeError: non-default argument</code> errors.</p> <p>Hint</p> <p>With Python 3.10, it is now possible to do it natively with dataclasses. Dataclasses 3.10 added the <code>kw_only</code> attribute (similar to attrs). It allows you to specify which fields are keyword_only, thus will be set at the end of the init, not causing an inheritance problem.</p> <pre><code>from dataclasses import dataclass\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Parent(AvroModel):\n    name: str\n    age: int\n\n\n@dataclass\nclass Child(Parent):\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n\n@dataclass\nclass Child2(Parent, AvroModel):\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n    class Meta:\n        schema_doc = False\n\n\nchild_schema = Child.avro_schema_to_python()\nchild_2_schema = Child2.avro_schema_to_python()\n\n\nassert child_schema[\"fields\"] == child_2_schema[\"fields\"]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#field-order","title":"Field order","text":"<p>The schema generation uses the same order of the python dataclass attributes has, for example. But what if you want to change the field order and specify a field that has a default value before a required value? This with a python dataclass won't work because required field must be declared before optional fields. Another IMPORTANT use case is when a schema was generated by a third party (we do not have control of if) and fields with defaults values are declared before the required ones, so using the <code>field_order</code> property will help us.</p> <p>The previous example generate has the following class</p> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n</code></pre> <p>which represents the schame:</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": false},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3}\n  ],\n  \"doc\": \"My User Class\",\n}\n</code></pre> <p>We want that the field <code>has_pets</code> at the beginning of the schema, for this we need to use the <code>field_order</code> property in the <code>Meta class</code>:</p> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        field_order = [\"has_pets\",]\n</code></pre> <p>which represents the schema</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": false},\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3}\n  ],\n  \"doc\": \"My User Class\",\n}\n</code></pre> <p>Warning</p> <p>Schemas with the same fields but with different order are NOT the same schema. In avro the field order is important</p>"},{"location":"records/#excluding-fields","title":"Excluding fields","text":"<p>It is possible to exclude fields from the schema using the <code>Meta.exclude</code> attribute. This can be helpful when we have fields that are not serializable.</p> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    last_name: str = \"Bond\"\n\n    class Meta:\n        namespace = \"test.com.ar/user/v1\"\n        aliases = [\n            \"User\",\n            \"My favorite User\",\n        ]\n        exclude = [\n            \"last_name\",\n        ]\n</code></pre> <p>which represents the schema whiout the field <code>last_name</code></p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"User\", \n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"}\n    ],\n    \"doc\": \"An User\", \n    \"namespace\": \"test.com.ar/user/v1\", \n    \"aliases\": [\"User\", \"My favorite User\"]\n</code></pre> <p>Warning</p> <p>If a required field is excluded from the schema then the deserialization will FAIL because a default value is not provided</p>"},{"location":"schema_relationships/","title":"Schema Relationships","text":""},{"location":"schema_relationships/#onetoone","title":"OneToOne","text":"An User has one Address example<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroModel):\n    \"An User with Address\"\n    name: str\n    age: int\n    address: Address\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"address\", \"type\": {\n      \"type\": \"record\",\n      \"name\": \"Address\",\n      \"fields\": [\n        {\"name\": \"street\",\"type\": \"string\"},\n        {\"name\": \"street_number\", \"type\": \"long\"}\n      ],\n      \"doc\": \"An Address\"\n      }\n    }\n  ],\n  \"doc\": \"An User with Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","title":"OneToOne Recursive Schema Relationship","text":"An User with only one friend :-(<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with self reference as friend\"\n    name: str\n    age: int\n    friend: typing.Type[\"User\"] = None\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friend\",\n      \"type\": [\"null\", \"User\"],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"User with self reference as friend\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetomany-schema-relationship","title":"OneToMany Schema Relationship","text":"An User has multiple Address example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> OneToMany with Map example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.Dict[str, Address]\n\n\nUser.avro_schema()\n\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","title":"OneToMany Recursive Schema Relationship","text":"OneToMany recursive example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n# Using a List (Avro Array)\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with self reference as friends\"\n    name: str\n    age: int\n    friends: typing.List[typing.Type[\"User\"]] = None\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friends\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"User\",\n        \"name\": \"friend\"\n      },\n      \"default\": []\n    }\n  ],\n  \"doc\": \"User with self reference as friends\"\n}'\n\n# Using a Dict (Avro Map)\n@dataclasses.dataclass\nclass User(AvroModel):\n  \"User with self reference as friends\"\n  name: str\n  age: int\n  friends: typing.Dict[str, typing.Type[\"User\"]] = None\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friends\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"User\",\n        \"name\": \"friend\"\n      },\n      \"default\": {}\n    }\n  ],\n  \"doc\": \"User with self reference as friends\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#avoid-name-collision-in-multiple-relationships","title":"Avoid name collision in multiple relationships","text":"<p>Sometimes we have relationships where a class is related more than once with a particular class. In those cases, the <code>predifne</code> type is used in order to generate a valid schema. It is a good practice but NOT neccesary to a define the <code>namespace</code> on the repeated <code>type</code>.</p> Repetead types<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nimport json\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"  # Good practise to use `namespaces`\n\n@dataclass\nclass Trip(AvroModel):\n    start_time: datetime\n    start_location: Location  # first relationship\n    finish_time: datetime\n    finish_location: Location  # second relationship\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"start_location\",\n      \"type\": {\"type\": \"record\",\n      \"name\": \"Location\",\n        \"fields\": [\n          {\"name\": \"latitude\", \"type\": \"double\"},\n          {\"name\": \"longitude\", \"type\": \"double\"}\n        ],\n      \"doc\": \"Location(latitude: float, longitude: float)\",\n      \"namespace\": \"types.location_type\"}},\n    {\n      \"name\": \"finish_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"finish_location\", \"type\": \"types.location_type.Location\"  // using the namespace and the Location type\n    }\n  ],\n  \"doc\": \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>or with <code>arrays</code> or <code>maps</code>:</p> <pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"\n        schema_doc = False\n\n\n@dataclasses.dataclass\nclass Trip(AvroModel):\n    start_location: Location\n    finish_location: typing.List[Location]\n\n    class Meta:\n        schema_doc = False\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_location\",\n      \"type\":\n        {\n          \"type\": \"record\",\n          \"name\": \"Location\",\n          \"fields\": [\n            {\n              \"name\": \"latitude\",\n              \"type\": \"double\"\n            },\n            {\n              \"name\": \"longitude\",\n              \"type\": \"double\"\n            }\n          ],\n          \"namespace\": \"types.location_type\"\n        }\n      },\n    {\n      \"name\": \"finish_location\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"types.location_type.Location\",\n        \"name\": \"finish_location\"\n      }\n    }\n  ]\n}'\n</code></pre> <pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"\n        schema_doc = False\n\n\n@dataclasses.dataclass\nclass Trip(AvroModel):\n    start_location: Location\n    finish_location: typing.Dict[str, Location]\n\n    class Meta:\n        schema_doc = False\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_location\",\n      \"type\": {\n        \"type\": \"record\",\n        \"name\": \"Location\",\n        \"fields\": [\n          {\n            \"name\": \"latitude\",\n            \"type\": \"double\"\n          },\n          {\n            \"name\": \"longitude\",\n            \"type\": \"double\"\n          }\n        ],\n        \"namespace\": \"types.location_type\"\n      }\n    },\n    {\n      \"name\": \"finish_location\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"types.location_type.Location\",\n        \"name\": \"finish_location\"\n      }\n    }\n  ]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If you want, also you can use custom name for nested items (<code>nested records</code>, <code>arrays</code> or <code>maps</code>) using the property <code>alias_nested_items</code> in <code>class Meta</code>:</p> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User with Address\"\n    name: str\n    age: int\n    address: Address  # default name Address\n\n    class Meta:\n        alias_nested_items = {\"address\": \"MySuperAddress\"}\n</code></pre> <p><code>User.avro_schema()</code> will generate:</p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\": [\n        {\n            \"name\": \"name\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"age\",\n            \"type\": \"long\"\n        },\n        {\n            \"name\": \"address\",\n            \"type\": {\n                \"type\": \"record\",\n                \"name\": \"MySuperAddress\",  // renamed it using alias_nested_items\n                \"fields\": [\n                    {\n                        \"name\": \"street\",\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"name\": \"street_number\",\n                        \"type\": \"long\"\n                    }\n                ],\n                \"doc\": \"An Address\"\n            }\n        } \n    ],\n    \"doc\": \"An User with Address\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#naming-clashes","title":"Naming clashes","text":"<p>Sometimes theare are <code>avro schemas</code> that contain name clashing between <code>field names</code> and <code>type names</code>, for example the following schema the record <code>Message</code> has a field called <code>MessageHeader</code> which is also a <code>type</code> record:</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Message\",\n  \"fields\": [\n    {\"name\": \"MessageBody\", \"type\": \"string\"},\n    {\n      \"name\": \"MessageHeader\",\n      \"type\": [\n        \"null\",\n        {\n          \"type\": \"array\",\n          \"name\": \"MessageHeader\",\n          \"items\": {\n            \"type\": \"record\",\n            \"name\": \"MessageHeader\",\n            \"fields\": [\n              {\"name\": \"version\", \"type\": \"string\"},\n              {\"name\": \"MessageType\", \"type\": \"string\"}\n            ]\n          }\n        }\n      ],\n      \"default\": null\n    }\n  ]\n}\n</code></pre> <p>From the previous schema we could have a model which might cause unexpected results:</p> <pre><code>from dataclasses_avroschema import AvroModel\nimport dataclasses\nimport typing\n\n\n@dataclasses.dataclass\nclass MessageHeader(AvroModel):\n    version: str\n    MessageType: str\n\n\n@dataclasses.dataclass\nclass Message(AvroModel):\n    MessageBody: str\n    MessageHeader: typing.Optional[typing.List[MessageHeader]] = None\n</code></pre> <p>If you try to use the <code>dataclasses</code> module and inspect the fields of the class <code>Message</code> doing <code>dataclasses.fields(Message)</code> you will see that the <code>typing hint</code> for the field <code>MessageHeader</code> is <code>typing.Optional[typing.List[NoneType]]</code>, which is should not be. This problem is cause by the way that <code>Python finds references</code> and because type annotations are evaluated after assignments.</p> <p>To solve this problem <code>dataclasses-avroschema</code> introduces just before the name clashing a new type definition which is used to set the <code>type hint</code> when it is required. Then <code>type</code> that causes the problem is defined outside the <code>class scope</code>.</p> <pre><code>from dataclasses_avroschema import AvroModel\nimport dataclasses\nimport typing\n\n\n@dataclasses.dataclass\nclass MessageHeader(AvroModel):\n    version: str\n    MessageType: str\n\n_MessageHeader = MessageHeader\n\n@dataclasses.dataclass\nclass Message(AvroModel):\n    MessageBody: str\n    MessageHeader: typing.Optional[typing.List[_MessageHeader]] = None\n</code></pre> <p>As a result the <code>typing hint</code> for the field <code>MessageHeader</code> becomes <code>typing.Optional[typing.List[__main__.MessageHeader]]</code>, which is the correct one.</p>"},{"location":"serialization/","title":"Serialization","text":"<p>Is possible to <code>serialize/deserialize</code> with the correspondent avro schema generated and the dataclass. In both cases we can do it with <code>avro</code> or <code>avro-json</code>.</p>"},{"location":"serialization/#instances-serialization","title":"Instances serialization","text":"Avro and avro-json serialization<pre><code>from dataclasses import dataclass\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\naddress_data = {\n    \"street\": \"test\",\n    \"street_number\": 10,\n}\n\n# create an Address instance\naddress = Address(**address_data)\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [address],\n}\n\n# create an User instance\nuser = User(**data_user)\n\nuser.serialize()\n# &gt;&gt;&gt; b\"\\x08john(\\x02\\x08test\\x14\\x00\"\n\nuser.serialize(serialization_type=\"avro-json\")\n# &gt;&gt;&gt; b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}'\n\nuser.to_json()\n# python dict &gt;&gt;&gt; {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>For serialization is neccesary to use python <code>dataclasses</code></p>"},{"location":"serialization/#deserialization","title":"Deserialization","text":"<p>Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance.</p> Avro and avro-json deserialization<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\navro_binary = b\"\\x08john(\\x02\\x08test\\x14\\x00\"\navro_json_binary = b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}'\n\n# return a new class instance!!\nUser.deserialize(avro_binary)\n# &gt;&gt;&gt; User(name='john', age=20, addresses=[Address(street='test', street_number=10)])\n\n# return a python dict\nUser.deserialize(avro_binary, create_instance=False)\n# &gt;&gt;&gt; {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}\n\n# return a new class instance!!\nUser.deserialize(avro_json_binary, serialization_type=\"avro-json\")\n# &gt;&gt;&gt; User(name='john', age=20, addresses=[Address(street='test', street_number=10)])\n\n# return a python dict\nUser.deserialize(avro_json_binary, serialization_type=\"avro-json\", create_instance=False)\n# &gt;&gt;&gt; {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/#deserialization-using-a-different-schema","title":"Deserialization using a different schema","text":"<p>To deserialize data encoded via a different schema, one can pass an optional <code>writer_schema: AvroModel | dict[str, Any]</code> attribute. It will be used by the fastavros <code>schemaless_reader</code>.</p> Deserialization with different schemas<pre><code>@dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n\n\n@dataclass\nclass UserCompatible(AvroModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n    class Meta:\n        schema_name = \"User\"\n\n\nuser_data = {\n    \"name\": \"G.R. Emlin\",\n    \"age\": 52,\n}\n\n# serialize data with the User schema\n&gt;&gt;&gt; serialized_user = User(**user_data).serialize()\n\n# deserialize user using a new, but compatible schema\n&gt;&gt;&gt; deserialized_user = UserCompatible.deserialize(serialized_user, writer_schema=User)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/#custom-serialization","title":"Custom Serialization","text":"<p>The <code>serialization/deserialization</code> process is built over fastavro. If you want to use another library or a different process, you can override the base <code>AvroModel</code>:</p> Custom serialization<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel, SerializationType\n\n\n@dataclasses.dataclass\nclass MyAvroModel(AvroModel):\n\n    ...\n\n    def serialize(self, serialization_type: SerializationType = \"avro\") -&gt; bytes:\n        # Get the schema as a python dict\n        schema = self.avro_schema_to_python()\n\n        # instance as python dict\n        data = self.asdict()\n\n        # call your custom serialization withe the avro schema and the data\n        return custom_serialization(schema, datam serialization_type=serialization_type)\n\n    @classmethod\n    def deserialize(\n        cls, data: bytes, serialization_type: SerializationType = \"avro\", create_instance: bool = True\n    ) -&gt; typing.Union[typing.Dict, \"AvroModel\"]:\n        # Get the schema as a python dict\n        schema = cls.avro_schema_to_python()\n\n        # get the python dict with the schema and the data (bytes)\n        payload = custom_deserialize(data, schema, serialization_type=serialization_type)\n\n        if create_instance:\n            return from_dict(data_class=cls, data=payload, config=Config(check_types=False))\n        return payload\n\n\n# and then inherits from your custom AvroModel\n\n@dataclasses.dataclass\nclass Address(MyAvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n</code></pre>"},{"location":"serialization/#encoding-for-unions-with-avro-json","title":"Encoding for unions with avro-json","text":"<p>When you have an <code>union</code> and you want to serialize a <code>payload</code> using <code>avro-json</code> you will notice that the <code>type</code> is added to each <code>union</code> field. This is needed because after the serialization process you need to know the <code>type</code> in order to <code>deserialize</code>:</p> <p>Do not confuse json with avro-json!!</p> Union encoding with avro-json example<pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: typing.Union[str, int]\n    logical_union: typing.Union[datetime.datetime, datetime.date, uuid.uuid4]\n\n\nmy_union = UnionSchema(first_union=10, logical_union=datetime.datetime.now())\n\n\nevent = my_union.serialize(serialization_type=\"avro-json\")\n\nprint(event)\n# long is added to each field\n&gt;&gt;&gt; b'{\"first_union\": {\"long\": 10}, \"logical_union\": {\"long\": 1647971584847}}'\n\nmy_union.deserialize(event, serialization_type=\"avro-json\")\n# &gt;&gt;&gt; UnionSchema(first_union=10, logical_union=datetime.datetime(2022, 3, 22, 17, 53, 4, 847000, tzinfo=datetime.timezone.utc))\n\n\n# bad data\nevent_2 = b'{\"first_union\": 10, \"logical_union\": {\"long\": 1647971584847}}'\n\nmy_union.deserialize(event_2, serialization_type=\"avro-json\")\n\nFile ~/Projects/dataclasses-avroschema/.venv/lib/python3.9/site-packages/fastavro/io/json_decoder.py:213, in AvroJSONDecoder.read_index(self)\n    211     label = \"null\"\n    212 else:\n--&gt; 213     label, data = self._current[self._key].popitem()\n    214     self._current[self._key] = data\n    215     # TODO: Do we need to do this?\n\nAttributeError: 'int' object has no attribute 'popitem'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/#utils","title":"Utils","text":"<p>The library includes two utils to serialize/deserialize using the <code>fastavro</code> as backend</p> <p>Serialize a payload into avro using <code>fastavro</code> as backend</p> <p>Attributes:</p> Name Type Description <code>payload</code> <code>Dict[str, Any]</code> <p>The payload to serialize</p> <code>serialization_type</code> <code>SerializationType</code> <p><code>avro</code> or <code>avro-json</code></p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes encoded in avro format</p> <p>Example</p> <pre><code>from dataclasses_avroschema import serialize\n\n\npayload = {'event': 'Hello world'}\nschema = {\n    'type': 'record',\n    'name': 'MyRecord',\n    'fields': [\n        {'name': 'event', 'type': 'string', 'default': 'Hello World'}\n    ]\n}\n\nevent = serialize(payload=payload, schema=schema)\nassert event == b'\u0016Hello world'\n</code></pre> <p>Deserialize an binary <code>event</code> into a python Dict using <code>fastavro</code> as backend</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>The event to deserialize</p> <code>schema</code> <code>bytes</code> <p>Dict[str, Any]: The schema to use for the deserialization</p> <code>serialization_type</code> <code>SerializationType</code> <p><code>avro</code> or <code>avro-json</code></p> <code>context</code> <code>Dict[str, Any] | None</code> <p>Optional extra context to use. Usually in includes an entry with all the extra models defined by the end user by name. Example AvroModel.name: AvroModel</p> <code>writer_schema</code> <code>Dict[str, Any] | None</code> <p>The schema that was used to write the event. If it is not provided it is assumed that the event was written with the <code>schema</code> provided</p> <p>Returns:</p> Type Description <code>JsonDict</code> <p>The object dezerialized python Dict</p> <p>Example</p> <pre><code>from dataclasses_avroschema import deserialize\n\n\nevent = b'\u0016Hello world'\nschema = {\n    'type': 'record',\n    'name': 'MyRecord',\n    'fields': [\n        {'name': 'event', 'type': 'string', 'default': 'Hello World'}\n    ]\n}\n\npayload = deserialize(data=event, schema=schema)\nassert payload == {'event': 'Hello world'}\n</code></pre>"}]}