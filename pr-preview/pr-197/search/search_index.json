{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses Avro Schema Generator Generate Avro Schemas from a Python class Requirements python 3.7+ Installation pip install dataclasses-avroschema or with pydantic funcionalities pip install dataclasses-avroschema [ pydantic ] Usage Generating the avro schema Trival Usage import enum import typing from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_color : FavoriteColor country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"long\" }, { \"name\" : \"favorite_color\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], }","title":"Introduction"},{"location":"#dataclasses-avro-schema-generator","text":"Generate Avro Schemas from a Python class","title":"Dataclasses Avro Schema Generator"},{"location":"#requirements","text":"python 3.7+","title":"Requirements"},{"location":"#installation","text":"pip install dataclasses-avroschema or with pydantic funcionalities pip install dataclasses-avroschema [ pydantic ]","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#generating-the-avro-schema","text":"Trival Usage import enum import typing from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_color : FavoriteColor country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"long\" }, { \"name\" : \"favorite_color\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], }","title":"Generating the avro schema"},{"location":"avro_schema/","text":"Avro Schemas and Python Class What is Apache Avro? Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON) Goal Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is. Records Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] } From a Python class to the Avro Schema Image that you have to define the previous User schema but you do not know avro, you know python: Generate the avro schema from a class from dataclasses_avroschema import AvroModel class User ( AvroModel ): name : str age : int has_pets : bool money : float User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' (This script is complete, it should run \"as is\") or create a python dictionary Avro schema to python User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], } and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"Avro Schema and Python Classes"},{"location":"avro_schema/#avro-schemas-and-python-class","text":"","title":"Avro Schemas and Python Class"},{"location":"avro_schema/#what-is-apache-avro","text":"Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON)","title":"What is Apache Avro?"},{"location":"avro_schema/#goal","text":"Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is.","title":"Goal"},{"location":"avro_schema/#records","text":"Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] }","title":"Records"},{"location":"avro_schema/#from-a-python-class-to-the-avro-schema","text":"Image that you have to define the previous User schema but you do not know avro, you know python: Generate the avro schema from a class from dataclasses_avroschema import AvroModel class User ( AvroModel ): name : str age : int has_pets : bool money : float User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' (This script is complete, it should run \"as is\") or create a python dictionary Avro schema to python User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], } and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"From a Python class to the Avro Schema"},{"location":"case/","text":"Sometimes we use avro schemas with different sources (some written in Scala, some in Python, etc). With the case you can generate your schemas according to your programming language convention: Example with CAPITALCASE import typing import enum from dataclasses_avroschema import AvroModel , case , types # New enum!! class FavoriteColor ( enum . Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance ( AvroModel ): name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : FavoriteColor has_car : bool = False country : str = \"Argentina\" address : str = None md5 : types . Fixed = types . Fixed ( 16 ) class Meta : schema_doc = False UserAdvance . avro_schema ( case_type = case . CAPITALCASE ) { \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"Name\" , \"type\" : \"string\" }, { \"name\" : \"Age\" , \"type\" : \"long\" }, { \"name\" : \"Pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"Pet\" } }, { \"name\" : \"Accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"Account\" } }, { \"name\" : \"Has_car\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"Favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"Favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ] } }, { \"name\" : \"Country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"Address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null }, { \"name\" : \"Md5\" , \"type\" : { \"type\" : \"fixed\" , \"name\" : \"Md5\" , \"size\" : 16 }} ] } ' (This script is complete, it should run \"as is\") Available cases: Case Example camelcase 'foo_bar_baz' # => \"fooBarBaz\" capitalcase 'foo_bar_baz' # => \"Foo_bar_baz\" constcase 'FooBarBaz' # => \"_FOO_BAR_BAZ\" lowercase 'FooBarBaz' # => \"foobarbaz\" pascalcase 'FooBarBaz' # => \"FooBarBaz\" pathcase 'foo_bar_baz' # => \"foo/bar/baz\" snakecase 'FooBarBaz' # => \"foo_bar_baz\" spinalcase 'FooBarBaz' # => \"-foo-bar-baz\" trimcase 'FooBarBaz' # => \"FooBarBaz\" uppercase 'FooBarBaz' # => \"FOOBARBAZ alphanumcase 'Foo_123 Bar!' # =>'Foo123Bar'","title":"Case Schemas"},{"location":"case/#available-cases","text":"Case Example camelcase 'foo_bar_baz' # => \"fooBarBaz\" capitalcase 'foo_bar_baz' # => \"Foo_bar_baz\" constcase 'FooBarBaz' # => \"_FOO_BAR_BAZ\" lowercase 'FooBarBaz' # => \"foobarbaz\" pascalcase 'FooBarBaz' # => \"FooBarBaz\" pathcase 'foo_bar_baz' # => \"foo/bar/baz\" snakecase 'FooBarBaz' # => \"foo_bar_baz\" spinalcase 'FooBarBaz' # => \"-foo-bar-baz\" trimcase 'FooBarBaz' # => \"FooBarBaz\" uppercase 'FooBarBaz' # => \"FOOBARBAZ alphanumcase 'Foo_123 Bar!' # =>'Foo123Bar'","title":"Available cases:"},{"location":"complex_types/","text":"Complex Types The following list represent the avro complex types mapped to python types: Avro Type Python Type enums enum.Enum arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.Fixed unions typing.Union unions with null typing.Optional records Python Class Enums Enum example import enum from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" class Meta : doc = \"A favorite color\" namespace = \"some.name.space\" aliases = [ \"Color\" , \"My favorite color\" ] class User ( AvroModel ): \"An User\" favorite_color : FavoriteColor = FavoriteColor . BLUE User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"Blue\" , \"Yellow\" , \"Green\" ], \"doc\" : \"A favorite color\" , \"namespace\" : \"some.name.space\" , \"aliases\" : [ \"Color\" , \"My favorite color\" ] }, \"default\" : \"Blue\" } ], \"doc\" : \"An User\" } ' Arrays Array example import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"long\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } ' Maps Map example import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } ' Fixed Fixed example import typing from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str md5 : types . Fixed = types . Fixed ( 16 , namespace = 'md5' , aliases = [ \"md5\" , \"hash\" ]) UnionSchema . avro_schema () { 'type' : 'record' , 'name' : 'UserAdvance' , 'fields' : [ { 'name' : 'name' , 'type' : 'string' }, { 'name' : 'md5' , 'type' : { 'type' : 'fixed' , 'name' : 'md5' , 'size' : 16 , 'namespace' : 'md5' , 'aliases' : [ 'md5' , 'hash' ]}} ], 'doc' : 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)' } Unions Union example import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] second_union : typing . Union [ str , int ] = dataclasses . field ( default_factory = lambda : [ \"test\" ]) third_union : typing . Union [ int , str ] = 'STRING TYPE' UnionSchema . avro_schema () { \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"first_union\" , \"type\" : [ \"string\" , \"long\" ]}, { \"name\" : \"logical_union\" , \"type\" : [ { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, { \"type\" : \"long\" , \"logicalType\" : \"date\" }, { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }]}, { \"name\" : \"second_union\" , \"type\" : [ \"string\" , \"long\" ], \"default\" : [ \"test\" ]}, { \"name\" : \"third_union\" , \"type\" : [ \"string\" , \"long\" ], \"default\" : \"STRING TYPE\" }], \"doc\" : \"Some Unions\" } # Union with Records class Bus ( AvroModel ): \"A Bus\" engine_name : str class Car ( AvroModel ): \"A Car\" engine_name : str class UnionSchema ( AvroModel ): \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) UnionSchema . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : null }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } ' Unions with typing.Optional typing.Optional[Any] is translated as an optional Union: typing.Union[Any, NoneType] where NoneType is always at the end Optional unions example import typing import dataclasses from dataclasses_avroschema import AvroModel from dataclasses import dataclass , field @dataclasses . dataclass class X ( AvroModel ): y : typing . Optional [ typing . List [ int ]] X . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"X\" , \"fields\" : [ { \"name\" : \"y\" , \"type\" : [{ \"type\" : \"array\" , \"items\" : \"long\" , \"name\" : \"y\" }, \"null\" ]} ], \"doc\" : \"X(y: Union[List[int], NoneType])\" } '","title":"Complex Types"},{"location":"complex_types/#complex-types","text":"The following list represent the avro complex types mapped to python types: Avro Type Python Type enums enum.Enum arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.Fixed unions typing.Union unions with null typing.Optional records Python Class","title":"Complex Types"},{"location":"complex_types/#enums","text":"Enum example import enum from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" class Meta : doc = \"A favorite color\" namespace = \"some.name.space\" aliases = [ \"Color\" , \"My favorite color\" ] class User ( AvroModel ): \"An User\" favorite_color : FavoriteColor = FavoriteColor . BLUE User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_color\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"Blue\" , \"Yellow\" , \"Green\" ], \"doc\" : \"A favorite color\" , \"namespace\" : \"some.name.space\" , \"aliases\" : [ \"Color\" , \"My favorite color\" ] }, \"default\" : \"Blue\" } ], \"doc\" : \"An User\" } '","title":"Enums"},{"location":"complex_types/#arrays","text":"Array example import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"long\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } '","title":"Arrays"},{"location":"complex_types/#maps","text":"Map example import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } '","title":"Maps"},{"location":"complex_types/#fixed","text":"Fixed example import typing from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str md5 : types . Fixed = types . Fixed ( 16 , namespace = 'md5' , aliases = [ \"md5\" , \"hash\" ]) UnionSchema . avro_schema () { 'type' : 'record' , 'name' : 'UserAdvance' , 'fields' : [ { 'name' : 'name' , 'type' : 'string' }, { 'name' : 'md5' , 'type' : { 'type' : 'fixed' , 'name' : 'md5' , 'size' : 16 , 'namespace' : 'md5' , 'aliases' : [ 'md5' , 'hash' ]}} ], 'doc' : 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)' }","title":"Fixed"},{"location":"complex_types/#unions","text":"Union example import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] second_union : typing . Union [ str , int ] = dataclasses . field ( default_factory = lambda : [ \"test\" ]) third_union : typing . Union [ int , str ] = 'STRING TYPE' UnionSchema . avro_schema () { \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"first_union\" , \"type\" : [ \"string\" , \"long\" ]}, { \"name\" : \"logical_union\" , \"type\" : [ { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, { \"type\" : \"long\" , \"logicalType\" : \"date\" }, { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }]}, { \"name\" : \"second_union\" , \"type\" : [ \"string\" , \"long\" ], \"default\" : [ \"test\" ]}, { \"name\" : \"third_union\" , \"type\" : [ \"string\" , \"long\" ], \"default\" : \"STRING TYPE\" }], \"doc\" : \"Some Unions\" } # Union with Records class Bus ( AvroModel ): \"A Bus\" engine_name : str class Car ( AvroModel ): \"A Car\" engine_name : str class UnionSchema ( AvroModel ): \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) UnionSchema . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : null }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } '","title":"Unions"},{"location":"complex_types/#unions-with-typingoptional","text":"typing.Optional[Any] is translated as an optional Union: typing.Union[Any, NoneType] where NoneType is always at the end Optional unions example import typing import dataclasses from dataclasses_avroschema import AvroModel from dataclasses import dataclass , field @dataclasses . dataclass class X ( AvroModel ): y : typing . Optional [ typing . List [ int ]] X . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"X\" , \"fields\" : [ { \"name\" : \"y\" , \"type\" : [{ \"type\" : \"array\" , \"items\" : \"long\" , \"name\" : \"y\" }, \"null\" ]} ], \"doc\" : \"X(y: Union[List[int], NoneType])\" } '","title":"Unions with typing.Optional"},{"location":"factories_and_fixtures/","text":"Dataclasses Avro Schema also includes a factory feature, so you can generate fast python instances and use them, for example, to test your data streaming pipelines. Instances can be genrated using the fake method. Basic usage import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] Address . fake () # >>>> Address(street='PxZJILDRgbXyhWrrPWxQ', street_number=2067) User . fake () # >>>> User(name='VGSBbOGfSGjkMDnefHIZ', age=8974, addresses=[Address(street='vNpPYgesiHUwwzGcmMiS', street_number=4790)]) (This script is complete, it should run \"as is\")","title":"Factory and fixtures"},{"location":"faust_records/","text":"This library also has support to generate Avro Schemas from a faust.Record Example: Basic usage import faust import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( faust . Record , AvroModel ): name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None class Meta : schema_doc = False UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } }, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' (This script is complete, it should run \"as is\")","title":"Faust Records"},{"location":"fields_specification/","text":"Apache Avro has Primitive Types , Complex Types and Logical Types , so we need to match these types with python types. Primitive Types and python representation The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str long int boolean bool double float null None bytes bytes int types.Int32 float types.Float32 Since Python does not have native int32 or float32 types, use the dataclasses_avroschema.types.Int32 and dataclasses_avroschema.types.Float32 types to annotate your classes. These types are simple wrappers around Python's default int and float types. Complex Types Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records. Avro Type Python Type enums tuple arrays list maps dict fixed types.Fixed unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Fixed uses the type name \"fixed\" and supports two attributes: name: a string naming this fixed (required). namespace, a string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). size: an integer, specifying the number of bytes per value (required). Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Under the Avro specifications, if a union field as a default, the type of the default must be the first listed type in the array. Dataclasses-avroschema will automatically generate the appropriate array if a default is provided. Note that an optional field (typing.Optional[T]) generates the union [T, null] , where T is the first element in the union. None will need to be explicitly declared the default to generate the appropriate schema, if the default should be None/null . Records: Records use the type name record and will represent the Schema . Logical Types A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Decimal: Represents a decimal.Decimal as bytes Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long time-micros types.TimeMicro long timestamp-millis datetime.datetime long timestamp-micros types.DateTimeMicro string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal decimal.Decimal Avro Field and Python Types Summary Python Type Avro Type Logical Type str string do not apply long int do not apply bool boolean do not apply double float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply enum.Enum enum do not apply types.Int32 int do not apply types.Float32 float do not apply typing.Union union do not apply typing.Optional union (with null ) do not apply Python class record do not apply datetime.date int date datetime.time int time-millis types.TimeMicro long time-micros datetime.datetime long timestamp-millis types.DateTimeMicro long timestamp-micros decimal.Decimal bytes decimal uuid.uuid4 string uuid uuid.UUID string uuid Adding Custom Field-level Attributes You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a \"doc\" attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. \"sensitivty\" . When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as \"name\" and others are specific to the datatype (e.g. array will have the items attribute). In order to add custom fields, you can use the field descriptor of the built-in dataclasses package and provide a dict of key-value pairs to the metadata parameter as in dataclasses.field(metadata={'doc': 'foo'}) . Examples Adding a doc attribute to fields from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' }) age : int = field ( metadata = { 'doc' : 'foo' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"doc\" : \"foo\" } ] } Adding an additional sensitivity attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' , 'sensitivity' : 'HIGH' }) age : int = field ( metadata = { 'doc' : 'foo' , 'sensitivity' : 'MEDIUM' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" , \"sensitivity\" : \"HIGH\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"doc\" : \"foo\" , \"sensitivity\" : \"MEDIUM\" } ] } (This script is complete, it should run \"as is\")","title":"Fields Specification"},{"location":"fields_specification/#primitive-types-and-python-representation","text":"The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str long int boolean bool double float null None bytes bytes int types.Int32 float types.Float32 Since Python does not have native int32 or float32 types, use the dataclasses_avroschema.types.Int32 and dataclasses_avroschema.types.Float32 types to annotate your classes. These types are simple wrappers around Python's default int and float types.","title":"Primitive Types and python representation"},{"location":"fields_specification/#complex-types","text":"Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records. Avro Type Python Type enums tuple arrays list maps dict fixed types.Fixed unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Fixed uses the type name \"fixed\" and supports two attributes: name: a string naming this fixed (required). namespace, a string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). size: an integer, specifying the number of bytes per value (required). Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Under the Avro specifications, if a union field as a default, the type of the default must be the first listed type in the array. Dataclasses-avroschema will automatically generate the appropriate array if a default is provided. Note that an optional field (typing.Optional[T]) generates the union [T, null] , where T is the first element in the union. None will need to be explicitly declared the default to generate the appropriate schema, if the default should be None/null . Records: Records use the type name record and will represent the Schema .","title":"Complex Types"},{"location":"fields_specification/#logical-types","text":"A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Decimal: Represents a decimal.Decimal as bytes Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long time-micros types.TimeMicro long timestamp-millis datetime.datetime long timestamp-micros types.DateTimeMicro string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal decimal.Decimal","title":"Logical Types"},{"location":"fields_specification/#avro-field-and-python-types-summary","text":"Python Type Avro Type Logical Type str string do not apply long int do not apply bool boolean do not apply double float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply enum.Enum enum do not apply types.Int32 int do not apply types.Float32 float do not apply typing.Union union do not apply typing.Optional union (with null ) do not apply Python class record do not apply datetime.date int date datetime.time int time-millis types.TimeMicro long time-micros datetime.datetime long timestamp-millis types.DateTimeMicro long timestamp-micros decimal.Decimal bytes decimal uuid.uuid4 string uuid uuid.UUID string uuid","title":"Avro Field and Python Types Summary"},{"location":"fields_specification/#adding-custom-field-level-attributes","text":"You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a \"doc\" attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. \"sensitivty\" . When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as \"name\" and others are specific to the datatype (e.g. array will have the items attribute). In order to add custom fields, you can use the field descriptor of the built-in dataclasses package and provide a dict of key-value pairs to the metadata parameter as in dataclasses.field(metadata={'doc': 'foo'}) .","title":"Adding Custom Field-level Attributes"},{"location":"fields_specification/#examples","text":"Adding a doc attribute to fields from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' }) age : int = field ( metadata = { 'doc' : 'foo' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"doc\" : \"foo\" } ] } Adding an additional sensitivity attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' , 'sensitivity' : 'HIGH' }) age : int = field ( metadata = { 'doc' : 'foo' , 'sensitivity' : 'MEDIUM' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" , \"sensitivity\" : \"HIGH\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"doc\" : \"foo\" , \"sensitivity\" : \"MEDIUM\" } ] } (This script is complete, it should run \"as is\")","title":"Examples"},{"location":"good_practices/","text":"Streaming Schema server and AvroModel First, let's clarify what a schema server is: It is a central place/repository that contains schemas with formats like avro , json or protobuf , with the purpose of exposing them through an API , so applications can access them and serialize/deserialize events. The schema server could have a RESTful interface so tasks like create , delete get schemas can be performed easily. In a pythonic world , you wouldn't need a schema server because using only the AvroModel will be enough as all the teams in your organization will use the same models, but this is not always the case. Somethimes, in big companies teams use different programming languages to talk the streaming layer, like python , java , go , etc. In this sense, you need a way to share schemas and you will need a schema server , otherwise it will be really hard to maintain the whole proccess. If you have a Schema Server and you want to use AvroModel , I would recommend you to add the schema_id in the Model.Meta that matches the schema in the schema server : Include schema_id in Meta import dataclasses from dataclasses_avroschema import AvroModel @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id} The purpose of the schema_id is to give a fast notion what the model is representing. Also, could be used as documentation Include event metadata avro schemas are used widely in streaming to serialize events, and with dataclasses-avroschemas it is straigtforward. Once that you have the event, it is a good practice to also add the event metadata at the moment of producing so consumers will know what to do. Event metadata: content-type or serialization-type : represents the way that the event was serialized. This could be avro or avro-json for example. schema-id : represents the schema-id that was used to serialize the event if exist. Produce event with metadata import asyncio import dataclasses from dataclasses_avroschema import AvroModel from aiokafka import AIOKafkaProducer @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id} async def produce (): # Naive example of producing an event producer = AIOKafkaProducer ( bootstrap_servers = 'localhost:9092' ) await producer . start () user = User ( \"Bond\" , age = \"50\" ) # create the event event = user . serialize () headers = [ ( \"content-type\" : b \"avro\" ), ( \"schema-id\" : User . Meta . schema_id . encode ()), ] await producer . send_and_wait ( \"my_topic\" , value = event , headers = headers ) await producer . stop () if __name__ == \"__main__\" : asyncio . run ( produce )","title":"Good Practices"},{"location":"good_practices/#streaming","text":"","title":"Streaming"},{"location":"good_practices/#schema-server-and-avromodel","text":"First, let's clarify what a schema server is: It is a central place/repository that contains schemas with formats like avro , json or protobuf , with the purpose of exposing them through an API , so applications can access them and serialize/deserialize events. The schema server could have a RESTful interface so tasks like create , delete get schemas can be performed easily. In a pythonic world , you wouldn't need a schema server because using only the AvroModel will be enough as all the teams in your organization will use the same models, but this is not always the case. Somethimes, in big companies teams use different programming languages to talk the streaming layer, like python , java , go , etc. In this sense, you need a way to share schemas and you will need a schema server , otherwise it will be really hard to maintain the whole proccess. If you have a Schema Server and you want to use AvroModel , I would recommend you to add the schema_id in the Model.Meta that matches the schema in the schema server : Include schema_id in Meta import dataclasses from dataclasses_avroschema import AvroModel @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id} The purpose of the schema_id is to give a fast notion what the model is representing. Also, could be used as documentation","title":"Schema server and AvroModel"},{"location":"good_practices/#include-event-metadata","text":"avro schemas are used widely in streaming to serialize events, and with dataclasses-avroschemas it is straigtforward. Once that you have the event, it is a good practice to also add the event metadata at the moment of producing so consumers will know what to do. Event metadata: content-type or serialization-type : represents the way that the event was serialized. This could be avro or avro-json for example. schema-id : represents the schema-id that was used to serialize the event if exist. Produce event with metadata import asyncio import dataclasses from dataclasses_avroschema import AvroModel from aiokafka import AIOKafkaProducer @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id} async def produce (): # Naive example of producing an event producer = AIOKafkaProducer ( bootstrap_servers = 'localhost:9092' ) await producer . start () user = User ( \"Bond\" , age = \"50\" ) # create the event event = user . serialize () headers = [ ( \"content-type\" : b \"avro\" ), ( \"schema-id\" : User . Meta . schema_id . encode ()), ] await producer . send_and_wait ( \"my_topic\" , value = event , headers = headers ) await producer . stop () if __name__ == \"__main__\" : asyncio . run ( produce )","title":"Include event metadata"},{"location":"kafka_examples/","text":"Under examples folder you can find 3 differents examples, one with aiokafka ( async ) showing the simplest use case when a AvroModel instance is serialized and sent it thorught kafka, and the event is consumed. The other two examples are sync using the kafka-python driver, where the avro-json serialization and schema evolution ( FULL compatibility) is shown. Minimal example Example with aiokafka driver import asyncio import enum from dataclasses import dataclass import random from aiokafka import AIOKafkaConsumer , AIOKafkaProducer from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : FavoriteColor = FavoriteColor . BLUE country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] async def consume ( loop , total_events = 10 ): consumer = AIOKafkaConsumer ( 'my_topic' , 'my_other_topic' , loop = loop , bootstrap_servers = 'localhost:9092' , group_id = \"my-group\" ) # Get cluster layout and join group `my-group` await consumer . start () run_consumer = True while run_consumer : try : # Consume messages async for msg in consumer : print ( f \"Message received: { msg . value } at { msg . timestamp } \" ) user = UserModel . deserialize ( msg . value ) print ( f \"Message deserialized: { user } \" ) except KeyboardInterrupt : # Will leave consumer group; perform autocommit if enabled. await consumer . stop () print ( \"Stoping consumer...\" ) run_consumer = False async def send ( loop , total_events = 10 ): producer = AIOKafkaProducer ( loop = loop , bootstrap_servers = 'localhost:9092' ) # Get cluster layout and initial topic/partition leadership information await producer . start () for event_number in range ( 1 , total_events + 1 ): # Produce message print ( f \"Sending event number { event_number } \" ) user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) # create the message message = user . serialize () await producer . send_and_wait ( \"my_topic\" , message ) # sleep for 2 seconds await asyncio . sleep ( 2 ) else : # Wait for all pending messages to be delivered or expire. await producer . stop () print ( \"Stoping producer...\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () tasks = asyncio . gather ( send ( loop ), consume ( loop )) loop . run_until_complete ( tasks ) (This script is complete, it should run \"as is\")","title":"Kafka examples"},{"location":"kafka_examples/#minimal-example","text":"Example with aiokafka driver import asyncio import enum from dataclasses import dataclass import random from aiokafka import AIOKafkaConsumer , AIOKafkaProducer from dataclasses_avroschema import AvroModel class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : FavoriteColor = FavoriteColor . BLUE country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] async def consume ( loop , total_events = 10 ): consumer = AIOKafkaConsumer ( 'my_topic' , 'my_other_topic' , loop = loop , bootstrap_servers = 'localhost:9092' , group_id = \"my-group\" ) # Get cluster layout and join group `my-group` await consumer . start () run_consumer = True while run_consumer : try : # Consume messages async for msg in consumer : print ( f \"Message received: { msg . value } at { msg . timestamp } \" ) user = UserModel . deserialize ( msg . value ) print ( f \"Message deserialized: { user } \" ) except KeyboardInterrupt : # Will leave consumer group; perform autocommit if enabled. await consumer . stop () print ( \"Stoping consumer...\" ) run_consumer = False async def send ( loop , total_events = 10 ): producer = AIOKafkaProducer ( loop = loop , bootstrap_servers = 'localhost:9092' ) # Get cluster layout and initial topic/partition leadership information await producer . start () for event_number in range ( 1 , total_events + 1 ): # Produce message print ( f \"Sending event number { event_number } \" ) user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) # create the message message = user . serialize () await producer . send_and_wait ( \"my_topic\" , message ) # sleep for 2 seconds await asyncio . sleep ( 2 ) else : # Wait for all pending messages to be delivered or expire. await producer . stop () print ( \"Stoping producer...\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () tasks = asyncio . gather ( send ( loop ), consume ( loop )) loop . run_until_complete ( tasks ) (This script is complete, it should run \"as is\")","title":"Minimal example"},{"location":"logical_types/","text":"Logical Types The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal decimal.Decimal Date Date example import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType ( AvroModel ): \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () DateLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } ' (This script is complete, it should run \"as is\") Time Time example import datetime from dataclasses_avroschema import AvroModel , TimeMicro a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes ( AvroModel ): \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () release_time_micro : TimeMicro = a_datetime . time () TimeLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : null }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 }, { \"name\" : \"release_time_micro\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"time-micros\" }, \"default\" : 64662000000.0 } ], \"doc\" : \"Time logical types\" } ' (This script is complete, it should run \"as is\") To use time-micros in avro schemas you need to use types.TimeMicro Datetime DateTime example import datetime from dataclasses_avroschema import AvroModel , DateTimeMicro a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType ( AvroModel ): \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime release_datetime_micro : DateTimeMicro = a_datetime DatetimeLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 }, { \"name\" : \"release_datetime_micro\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-micros\" }, \"default\" : 1570903062000000.0 } ], \"doc\" : \"Datetime logical types\" } ' (This script is complete, it should run \"as is\") To use timestamp-micros in avro schemas you need to use types.DateTimeMicro UUID UUID example import uuid from dataclasses_avroschema import AvroModel class UUIDLogicalTypes ( AvroModel ): \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () UUIDLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : null }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } ' (This script is complete, it should run \"as is\") Decimal The below code shows an example on how to use decimals. There's a few important things to note: * A default IS REQUIRED in order to set scale and precision on the Avro schema * It is strongly recommended to set these explicitly using types.Decimal(scale=, precision=) * They can be set implicitly by using a default decimal.Decimal * If set implicitly, scale and precision will be derived from the default as follows: default : decimal . Decimal = decimal . Decimal ( '3.14' ) sign , digits , exp = default . as_tuple () precision = len ( digits ) scale = exp * - 1 # Avro schema defines scale as a positive, as_tuple provides negative * This CAN and WILL have strange consequences if not careful, ESPECIALLY if constructing decimal.Decimal with a float. For example: string_definition : decimal . Decimal = decimal . Decimal ( '3.14' ) # scale = 2, precision = 3 float_definition : decimal . Decimal = decimal . Decimal ( 3.14 ) # scale = 51, precision = 52 Decimal example import decimal from dataclasses_avroschema import AvroModel , types class DecimalLogicalTypes ( AvroModel ): \"Decimal logical types\" explicit : decimal . Decimal = types . Decimal ( scale = 2 , precision = 3 ) explicit_with_default : decimal . Decimal = types . Decimal ( scale = 2 , precision = 3 , default = decimal . Decimal ( '3.14' )) implicit : decimal . Decimal = decimal . Decimal ( '3.14' ) # sets scale = 2, precision = 3, derived from provided default # will_error: decimal.Decimal # THIS WILL ERROR DecimalLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DecimalLogicalTypes\" , \"fields\" : [ { \"name\" : \"explicit\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 } }, { \"name\" : \"explicit_with_default\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 }, \"default\" : \" \\\\ u013a\" }, { \"name\" : \"implicit\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 }, \"default\" : \" \\\\ u013a\" } ], \"doc\" : \"Decimal logical types\" } ' (This script is complete, it should run \"as is\")","title":"Logical Types"},{"location":"logical_types/#logical-types","text":"The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID bytes decimal decimal.Decimal","title":"Logical Types"},{"location":"logical_types/#date","text":"Date example import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType ( AvroModel ): \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () DateLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } ' (This script is complete, it should run \"as is\")","title":"Date"},{"location":"logical_types/#time","text":"Time example import datetime from dataclasses_avroschema import AvroModel , TimeMicro a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes ( AvroModel ): \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () release_time_micro : TimeMicro = a_datetime . time () TimeLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : null }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 }, { \"name\" : \"release_time_micro\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"time-micros\" }, \"default\" : 64662000000.0 } ], \"doc\" : \"Time logical types\" } ' (This script is complete, it should run \"as is\") To use time-micros in avro schemas you need to use types.TimeMicro","title":"Time"},{"location":"logical_types/#datetime","text":"DateTime example import datetime from dataclasses_avroschema import AvroModel , DateTimeMicro a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType ( AvroModel ): \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime release_datetime_micro : DateTimeMicro = a_datetime DatetimeLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 }, { \"name\" : \"release_datetime_micro\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-micros\" }, \"default\" : 1570903062000000.0 } ], \"doc\" : \"Datetime logical types\" } ' (This script is complete, it should run \"as is\") To use timestamp-micros in avro schemas you need to use types.DateTimeMicro","title":"Datetime"},{"location":"logical_types/#uuid","text":"UUID example import uuid from dataclasses_avroschema import AvroModel class UUIDLogicalTypes ( AvroModel ): \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () UUIDLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : null }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } ' (This script is complete, it should run \"as is\")","title":"UUID"},{"location":"logical_types/#decimal","text":"The below code shows an example on how to use decimals. There's a few important things to note: * A default IS REQUIRED in order to set scale and precision on the Avro schema * It is strongly recommended to set these explicitly using types.Decimal(scale=, precision=) * They can be set implicitly by using a default decimal.Decimal * If set implicitly, scale and precision will be derived from the default as follows: default : decimal . Decimal = decimal . Decimal ( '3.14' ) sign , digits , exp = default . as_tuple () precision = len ( digits ) scale = exp * - 1 # Avro schema defines scale as a positive, as_tuple provides negative * This CAN and WILL have strange consequences if not careful, ESPECIALLY if constructing decimal.Decimal with a float. For example: string_definition : decimal . Decimal = decimal . Decimal ( '3.14' ) # scale = 2, precision = 3 float_definition : decimal . Decimal = decimal . Decimal ( 3.14 ) # scale = 51, precision = 52 Decimal example import decimal from dataclasses_avroschema import AvroModel , types class DecimalLogicalTypes ( AvroModel ): \"Decimal logical types\" explicit : decimal . Decimal = types . Decimal ( scale = 2 , precision = 3 ) explicit_with_default : decimal . Decimal = types . Decimal ( scale = 2 , precision = 3 , default = decimal . Decimal ( '3.14' )) implicit : decimal . Decimal = decimal . Decimal ( '3.14' ) # sets scale = 2, precision = 3, derived from provided default # will_error: decimal.Decimal # THIS WILL ERROR DecimalLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DecimalLogicalTypes\" , \"fields\" : [ { \"name\" : \"explicit\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 } }, { \"name\" : \"explicit_with_default\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 }, \"default\" : \" \\\\ u013a\" }, { \"name\" : \"implicit\" , \"type\" : { \"type\" : \"bytes\" , \"logicalType\" : \"decimal\" , \"precision\" : 3 , \"scale\" : 2 }, \"default\" : \" \\\\ u013a\" } ], \"doc\" : \"Decimal logical types\" } ' (This script is complete, it should run \"as is\")","title":"Decimal"},{"location":"migration_guide/","text":"Migration from previous versions to 0.27.0 types.Enum was replaced with enum.Enum . You must create your custom enum, example: import dataclasses from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str age : int favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) # --> replace with field!!! should be replaced by: import enum import dataclasses from dataclasses_avroschema import AvroModel # New enum!! class FavoriteColor ( enum . Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance : name : str age : int favorite_colors : FavoriteColor = FavoriteColor . BLUE # --> field updated!!! Migration from previous versions to 0.23.0 Now the name for Nested record uses the class.__name__ instead of `class.__name__.lower()_record . having this schemas: class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] # PREVIOUS User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"address_record\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } # VERSIONS 0.23.0 User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } Now we use namespaces when same types are referenced multiple times (DRY), so you MUST define the property namespace : class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" # REQUIRED!!!! class Trip ( AvroModel ): start_time : datetime . datetime start_location : Location finish_time : datetime . datetime finish_location : Location Trip . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"doc\" : \"Location(latitude: float, longitude: float)\" , \"namespace\" : \"types.location_type\" }}, { \"name\" : \"finish_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"finish_location\" , \"type\" : \"types.location_type.Location\" // using the namespace } ], \"doc\" : \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\" } Migration from previous versions to 0.14.0 Now all the dataclasses should inheritance from AvroModel and not use anymore the SchemaGenerator : # Versions < 0.14.0 import typing from dataclasses_avroschema import SchemaGenerator , types class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () # New versions from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None User . avro_schema () Another changes introduced was the way that extra avro attributes are represented, like namespace , aliases and whether to include avro documentation : class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User , include_schema_doc = False ) . avro_schema () # Now is perform using a Meta class class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ]","title":"Migration Guide"},{"location":"migration_guide/#migration-from-previous-versions-to-0270","text":"types.Enum was replaced with enum.Enum . You must create your custom enum, example: import dataclasses from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str age : int favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) # --> replace with field!!! should be replaced by: import enum import dataclasses from dataclasses_avroschema import AvroModel # New enum!! class FavoriteColor ( enum . Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance : name : str age : int favorite_colors : FavoriteColor = FavoriteColor . BLUE # --> field updated!!!","title":"Migration from previous versions to 0.27.0"},{"location":"migration_guide/#migration-from-previous-versions-to-0230","text":"Now the name for Nested record uses the class.__name__ instead of `class.__name__.lower()_record . having this schemas: class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] # PREVIOUS User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"address_record\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } # VERSIONS 0.23.0 User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } Now we use namespaces when same types are referenced multiple times (DRY), so you MUST define the property namespace : class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" # REQUIRED!!!! class Trip ( AvroModel ): start_time : datetime . datetime start_location : Location finish_time : datetime . datetime finish_location : Location Trip . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"doc\" : \"Location(latitude: float, longitude: float)\" , \"namespace\" : \"types.location_type\" }}, { \"name\" : \"finish_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"finish_location\" , \"type\" : \"types.location_type.Location\" // using the namespace } ], \"doc\" : \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\" }","title":"Migration from previous versions to 0.23.0"},{"location":"migration_guide/#migration-from-previous-versions-to-0140","text":"Now all the dataclasses should inheritance from AvroModel and not use anymore the SchemaGenerator : # Versions < 0.14.0 import typing from dataclasses_avroschema import SchemaGenerator , types class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () # New versions from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None User . avro_schema () Another changes introduced was the way that extra avro attributes are represented, like namespace , aliases and whether to include avro documentation : class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User , include_schema_doc = False ) . avro_schema () # Now is perform using a Meta class class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ]","title":"Migration from previous versions to 0.14.0"},{"location":"primitive_types/","text":"The following list represent the avro primitive types mapped to python types: Avro Type Python Type string str int,long int boolean bool float,double float null None bytes bytes Examples Primitive types from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int height : types . Float32 weight : types . Int32 is_student : bool money_available : float encoded : bytes User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"height\" , \"type\" : \"float\" }, { \"name\" : \"weight\" , \"type\" : \"int\" }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" }, { \"name\" : \"money_available\" , \"type\" : \"double\" }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" } ], \"doc\" : \"An User\" } ' (This script is complete, it should run \"as is\") Primitive types with defaul values from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"An User\" name : str = None age : int = None height : types . Float32 = None weight : types . Int32 = None is_student : bool = None money_available : float = None encoded : bytes = None User . avro_schema () # We can see the use of null in the schema generated: '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null }, { \"name\" : \"age\" , \"type\" : [ \"null\" , \"long\" ], \"default\" : null }, { \"name\" : \"height\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : null }, { \"name\" : \"weight\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : null }, { \"name\" : \"is_student\" , \"type\" : [ \"null\" , \"boolean\" ], \"default\" : null }, { \"name\" : \"money_available\" , \"type\" : [ \"null\" , \"double\" ], \"default\" : null }, { \"name\" : \"encoded\" , \"type\" : [ \"null\" , \"bytes\" ], \"default\" : null } ], \"doc\" : \"An User\" } ' # Or with null as a second type argument: class User ( AvroModel ): \"An User\" name : str = 'Juan' age : int = 20 height : types . Float32 = 165.3 weight : types . Int32 = 72 is_student : bool = True money_available : float = 100.2 encoded : bytes = b \"hi\" User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"default\" : \"Juan\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"default\" : 20 }, { \"name\" : \"height\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : 165.3 }, { \"name\" : \"weight\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : 72 }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" , \"default\" : true }, { \"name\" : \"money_available\" , \"type\" : \"double\" , \"default\" : 100.2 }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" , \"default\" : \"hi\" } ], \"doc\" : \"An User\" } ' (This script is complete, it should run \"as is\")","title":"Primitive Types"},{"location":"primitive_types/#examples","text":"Primitive types from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int height : types . Float32 weight : types . Int32 is_student : bool money_available : float encoded : bytes User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"height\" , \"type\" : \"float\" }, { \"name\" : \"weight\" , \"type\" : \"int\" }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" }, { \"name\" : \"money_available\" , \"type\" : \"double\" }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" } ], \"doc\" : \"An User\" } ' (This script is complete, it should run \"as is\") Primitive types with defaul values from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"An User\" name : str = None age : int = None height : types . Float32 = None weight : types . Int32 = None is_student : bool = None money_available : float = None encoded : bytes = None User . avro_schema () # We can see the use of null in the schema generated: '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null }, { \"name\" : \"age\" , \"type\" : [ \"null\" , \"long\" ], \"default\" : null }, { \"name\" : \"height\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : null }, { \"name\" : \"weight\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : null }, { \"name\" : \"is_student\" , \"type\" : [ \"null\" , \"boolean\" ], \"default\" : null }, { \"name\" : \"money_available\" , \"type\" : [ \"null\" , \"double\" ], \"default\" : null }, { \"name\" : \"encoded\" , \"type\" : [ \"null\" , \"bytes\" ], \"default\" : null } ], \"doc\" : \"An User\" } ' # Or with null as a second type argument: class User ( AvroModel ): \"An User\" name : str = 'Juan' age : int = 20 height : types . Float32 = 165.3 weight : types . Int32 = 72 is_student : bool = True money_available : float = 100.2 encoded : bytes = b \"hi\" User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"default\" : \"Juan\" }, { \"name\" : \"age\" , \"type\" : \"long\" , \"default\" : 20 }, { \"name\" : \"height\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : 165.3 }, { \"name\" : \"weight\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : 72 }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" , \"default\" : true }, { \"name\" : \"money_available\" , \"type\" : \"double\" , \"default\" : 100.2 }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" , \"default\" : \"hi\" } ], \"doc\" : \"An User\" } ' (This script is complete, it should run \"as is\")","title":"Examples"},{"location":"pydantic/","text":"It is possible to use pydantic with dataclasses-avroschema making use of AvroBaseModel : You must use use all the pydantic features and all dataclasses-avroschema functionality will be injected. Avro and Json schemas Basic usage import typing import enum from dataclasses_avroschema.avrodantic import AvroBaseModel from pydantic import Field class FavoriteColor ( str , enum . Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance ( AvroBaseModel ): name : str age : int pets : typing . List [ str ] = Field ( default_factory = lambda : [ \"dog\" , \"cat\" ]) accounts : typing . Dict [ str , int ] = Field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : FavoriteColor = FavoriteColor . BLUE country : str = \"Argentina\" address : str = None class Meta : schema_doc = False # Avro schema UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ]}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 }}, { \"name\" : \"has_car\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, \"default\" : \"BLUE\" }, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' # Json schema UserAdvance . json_schema () '{ \"title\" : \"UserAdvance\" , \"type\" : \"object\" , \"properties\" : { \"name\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"age\" : { \"title\" : \"Age\" , \"type\" : \"integer\" }, \"pets\" : { \"title\" : \"Pets\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }}, \"accounts\" : { \"title\" : \"Accounts\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"integer\" }}, \"has_car\" : { \"title\" : \"Has Car\" , \"default\" : false , \"type\" : \"boolean\" }, \"favorite_colors\" : { \"default\" : \"BLUE\" , \"allOf\" : [{ \"$ref\" : \"#/definitions/FavoriteColor\" }]}, \"country\" : { \"title\" : \"Country\" , \"default\" : \"Argentina\" , \"type\" : \"string\" }, \"address\" : { \"title\" : \"Address\" , \"type\" : \"string\" }}, \"required\" : [ \"name\" , \"age\" ], \"definitions\" : { \"FavoriteColor\" : { \"title\" : \"FavoriteColor\" , \"description\" : \"An enumeration.\" , \"enum\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"type\" : \"string\" }}} ' (This script is complete, it should run \"as is\") You must use pydantic.Field instead of dataclasses.field Pydantic and dataclasses_avroschema batteries To dict and json user = UserAdvance ( name = \"bond\" , age = 50 ) # to_json from dataclasses-avroschema is the same that json from pydantic assert user . to_json () == user . json () # to_dict from dataclasses-avroschema is the same that dict from pydantic assert user . to_dict () == user . dict () serialization event = user . serialize () print ( event ) # >>> b'\\x08bondd\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x00\\x12Argentina\\x00' UserAdvance . deserialize ( data = event ) # >>> UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=<FavoriteColor.BLUE: 'BLUE'>, country='Argentina', address=None) parse_obj import typing from dataclasses_avroschema.avrodantic import AvroBaseModel class Address ( AvroBaseModel ): \"An Address\" street : str street_number : int class User ( AvroBaseModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [{ \"street\" : \"test\" , \"street_number\" : 10 , }], } user = User . parse_obj ( data = data_user ) assert type ( user . addresses [ 0 ]) is Address (This script is complete, it should run \"as is\")","title":"Pydantic"},{"location":"pydantic/#avro-and-json-schemas","text":"Basic usage import typing import enum from dataclasses_avroschema.avrodantic import AvroBaseModel from pydantic import Field class FavoriteColor ( str , enum . Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance ( AvroBaseModel ): name : str age : int pets : typing . List [ str ] = Field ( default_factory = lambda : [ \"dog\" , \"cat\" ]) accounts : typing . Dict [ str , int ] = Field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : FavoriteColor = FavoriteColor . BLUE country : str = \"Argentina\" address : str = None class Meta : schema_doc = False # Avro schema UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ]}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"long\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 }}, { \"name\" : \"has_car\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, \"default\" : \"BLUE\" }, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' # Json schema UserAdvance . json_schema () '{ \"title\" : \"UserAdvance\" , \"type\" : \"object\" , \"properties\" : { \"name\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"age\" : { \"title\" : \"Age\" , \"type\" : \"integer\" }, \"pets\" : { \"title\" : \"Pets\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }}, \"accounts\" : { \"title\" : \"Accounts\" , \"type\" : \"object\" , \"additionalProperties\" : { \"type\" : \"integer\" }}, \"has_car\" : { \"title\" : \"Has Car\" , \"default\" : false , \"type\" : \"boolean\" }, \"favorite_colors\" : { \"default\" : \"BLUE\" , \"allOf\" : [{ \"$ref\" : \"#/definitions/FavoriteColor\" }]}, \"country\" : { \"title\" : \"Country\" , \"default\" : \"Argentina\" , \"type\" : \"string\" }, \"address\" : { \"title\" : \"Address\" , \"type\" : \"string\" }}, \"required\" : [ \"name\" , \"age\" ], \"definitions\" : { \"FavoriteColor\" : { \"title\" : \"FavoriteColor\" , \"description\" : \"An enumeration.\" , \"enum\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"type\" : \"string\" }}} ' (This script is complete, it should run \"as is\") You must use pydantic.Field instead of dataclasses.field","title":"Avro and Json schemas"},{"location":"pydantic/#pydantic-and-dataclasses_avroschema-batteries","text":"To dict and json user = UserAdvance ( name = \"bond\" , age = 50 ) # to_json from dataclasses-avroschema is the same that json from pydantic assert user . to_json () == user . json () # to_dict from dataclasses-avroschema is the same that dict from pydantic assert user . to_dict () == user . dict () serialization event = user . serialize () print ( event ) # >>> b'\\x08bondd\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x00\\x12Argentina\\x00' UserAdvance . deserialize ( data = event ) # >>> UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=<FavoriteColor.BLUE: 'BLUE'>, country='Argentina', address=None) parse_obj import typing from dataclasses_avroschema.avrodantic import AvroBaseModel class Address ( AvroBaseModel ): \"An Address\" street : str street_number : int class User ( AvroBaseModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [{ \"street\" : \"test\" , \"street_number\" : 10 , }], } user = User . parse_obj ( data = data_user ) assert type ( user . addresses [ 0 ]) is Address (This script is complete, it should run \"as is\")","title":"Pydantic and dataclasses_avroschema batteries"},{"location":"records/","text":"Records Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using Class Meta . Basic usage from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"money\" , \"type\" : \"double\" , \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } ' (This script is complete, it should run \"as is\") Class Meta The class Meta is used to specify schema attributes that are not represented by the class fields like namespace , aliases and whether to include the schema documentation . One can also provide a custom schema name (the default is the class' name) via schema_name attribute and alias_nested_items when you have nested items and you want to use custom naming for them. Class Meta description class Meta : schema_name = \"Name other than the class name\" schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] alias_nested_items = { \"address\" : \"Address\" } schema_doc (Union[boolean, str]) : Whether include the schema documentation generated from docstrings . Default True . If the value is a string if will be used to generate the schema documentation. namespace (optional[str]) : Schema namespace. Default None aliases (optional[List[str]]) : Schema aliases. Default None alias_nested_items (optional[Dict[str, str]]) : Nested items names Record to json and dict You can get the json and dict representation of your instance using to_json and to_dict methods: Json and Dict example import dataclasses from dataclasses_avroschema import AvroModel @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 user = User ( name = \"Bond\" , age = 50 ) user . to_json () # >>> '{\"name\": \"Bond\", \"age\": 50, \"has_pets\": false, \"money\": 100.3}' user . to_dict () # >>> {'name': 'Bond', 'age': 50, 'has_pets': False, 'money': 100.3} (This script is complete, it should run \"as is\") Validation Python classes that inheritance from AvroModel has a validate method. This method validates whether the instance data matches the schema that it represents, for example: Validation example from dataclasses import dataclass from dataclasses_avroschema import AvroModel @dataclass class User ( AvroModel ): name : str age : int has_pets : bool money : float encoded : bytes # this creates a proper instance user_instance = User ( name = \"a name\" , age = 10 , has_pets = True , money = 0 , encoded = b 'hi' , ) assert user_instance . validate () # set 1 to the name attribute and the fastavro validation should fail # This is possible because in dataclasses there is not restriction, # but at the moment of using pydantic this will change user_instance . name = 1 with pytest . raises ( ValidationError ) as exc : assert user_instance . validate () assert json . loads ( str ( exc . value )) == [ \"User.name is <1> of type <class 'int'> expected string\" ] (This script is complete, it should run \"as is\") Nested schema resolution directly from dictionaries Sometimes you have a dictionary and you want to create an instance without creating the nested objects. This library follows the same approach as pydantic with parse_obj method. This is also valid for avrodantic.AvroBaseModel . from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [{ \"street\" : \"test\" , \"street_number\" : 10 , }], } user = User . parse_obj ( data = data_user ) assert type ( user . addresses [ 0 ]) is Address (This script is complete, it should run \"as is\")","title":"Records"},{"location":"records/#records","text":"Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using Class Meta . Basic usage from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"money\" , \"type\" : \"double\" , \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } ' (This script is complete, it should run \"as is\")","title":"Records"},{"location":"records/#class-meta","text":"The class Meta is used to specify schema attributes that are not represented by the class fields like namespace , aliases and whether to include the schema documentation . One can also provide a custom schema name (the default is the class' name) via schema_name attribute and alias_nested_items when you have nested items and you want to use custom naming for them. Class Meta description class Meta : schema_name = \"Name other than the class name\" schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] alias_nested_items = { \"address\" : \"Address\" } schema_doc (Union[boolean, str]) : Whether include the schema documentation generated from docstrings . Default True . If the value is a string if will be used to generate the schema documentation. namespace (optional[str]) : Schema namespace. Default None aliases (optional[List[str]]) : Schema aliases. Default None alias_nested_items (optional[Dict[str, str]]) : Nested items names","title":"Class Meta"},{"location":"records/#record-to-json-and-dict","text":"You can get the json and dict representation of your instance using to_json and to_dict methods: Json and Dict example import dataclasses from dataclasses_avroschema import AvroModel @dataclasses . dataclass class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 user = User ( name = \"Bond\" , age = 50 ) user . to_json () # >>> '{\"name\": \"Bond\", \"age\": 50, \"has_pets\": false, \"money\": 100.3}' user . to_dict () # >>> {'name': 'Bond', 'age': 50, 'has_pets': False, 'money': 100.3} (This script is complete, it should run \"as is\")","title":"Record to json and dict"},{"location":"records/#validation","text":"Python classes that inheritance from AvroModel has a validate method. This method validates whether the instance data matches the schema that it represents, for example: Validation example from dataclasses import dataclass from dataclasses_avroschema import AvroModel @dataclass class User ( AvroModel ): name : str age : int has_pets : bool money : float encoded : bytes # this creates a proper instance user_instance = User ( name = \"a name\" , age = 10 , has_pets = True , money = 0 , encoded = b 'hi' , ) assert user_instance . validate () # set 1 to the name attribute and the fastavro validation should fail # This is possible because in dataclasses there is not restriction, # but at the moment of using pydantic this will change user_instance . name = 1 with pytest . raises ( ValidationError ) as exc : assert user_instance . validate () assert json . loads ( str ( exc . value )) == [ \"User.name is <1> of type <class 'int'> expected string\" ] (This script is complete, it should run \"as is\")","title":"Validation"},{"location":"records/#nested-schema-resolution-directly-from-dictionaries","text":"Sometimes you have a dictionary and you want to create an instance without creating the nested objects. This library follows the same approach as pydantic with parse_obj method. This is also valid for avrodantic.AvroBaseModel . from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [{ \"street\" : \"test\" , \"street_number\" : 10 , }], } user = User . parse_obj ( data = data_user ) assert type ( user . addresses [ 0 ]) is Address (This script is complete, it should run \"as is\")","title":"Nested schema resolution directly from dictionaries"},{"location":"redis_examples/","text":"Minimal redis example using redis streams with walrus driver. Example with walrus driver from dataclasses import dataclass import enum import random from time import sleep from walrus import Database # A subclass of the redis-py Redis client. from dataclasses_avroschema import AvroModel , types class FavoriteColor ( enum . Enum ): BLUE = \"Blue\" YELLOW = \"Yellow\" GREEN = \"Green\" @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : FavoriteColor = FavoriteColor . BLUE country : str = \"Argentina\" address : str = None testing : bool = False class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] def consume ( consumer_group ): # read new messages in the stream while True : result = consumer_group . my_stream . read ( count = 1 , block = 1000 ) # Each record has the followinf format # [(b'1598545738231-0', {b'message': b'\\x06KimT\\x00\\x12Argentina\\x00\\x00'})] if result : message_id , message_content = result [ 0 ] if message_id : value = message_content [ b 'message' ] print ( f \"Processing message { message_id } with value { value } \" ) user = UserModel . deserialize ( value ) print ( user ) def produce ( consumer_group ): for i in range ( 10 ): # create an instance of User v1 user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) msgid = consumer_group . my_stream . add ({ \"message\" : user . serialize ()}) print ( f \"Producing message { msgid } \" ) print ( \"Producer finished....\" ) print ( \"#\" * 80 ) sleep ( 2 ) if __name__ == \"__main__\" : db = Database () stream_name = 'my-stream' db . Stream ( stream_name ) # Create a new stream instance # create the consumer group consumer_group = db . consumer_group ( 'my-consumer-group-1' , [ stream_name ]) consumer_group . create () # Create the consumer group. consumer_group . set_id ( '$' ) produce ( consumer_group ) consume ( consumer_group ) (This script is complete, it should run \"as is\")","title":"Redis examples"},{"location":"schema_relationships/","text":"Schema Relationships OneToOne An User has one Address example from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } ' (This script is complete, it should run \"as is\") OneToOne Recursive Schema Relationship An User with only one friend :-( import typing from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friend\" , \"type\" : [ \"null\" , \"User\" ], \"default\" : null } ], \"doc\" : \"User with self reference as friend\" } ' (This script is complete, it should run \"as is\") OneToMany Schema Relationship An User has multiple Address example import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' (This script is complete, it should run \"as is\") OneToMany with Map example import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' (This script is complete, it should run \"as is\") OneToMany Recursive Schema Relationship OneToMany recursive example import typing from dataclasses_avroschema import AvroModel # Using a List (Avro Array) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" }, \"default\" : [] } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" }, \"default\" : {} } ], \"doc\" : \"User with self reference as friends\" } ' (This script is complete, it should run \"as is\") Avoid name collision in multiple relationships Sometimes we have relationships where a class is related more than once with a particular class, and the name for the nested schemas must be different, otherwise we will generate an invalid avro schema . For those cases, you MUST define the namespace . Avoiding name collision example from dataclasses import dataclass from datetime import datetime import json from dataclasses_avroschema import AvroModel @dataclass class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" @dataclass class Trip ( AvroModel ): start_time : datetime start_location : Location # first relationship finish_time : datetime finish_location : Location # second relationship Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"doc\" : \"Location(latitude: float, longitude: float)\" , \"namespace\" : \"types.location_type\" }}, { \"name\" : \"finish_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"finish_location\" , \"type\" : \"types.location_type.Location\" // using the namespace } ], \"doc\" : \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\" } (This script is complete, it should run \"as is\") or with arrays or maps : class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" schema_doc = False class Trip ( AvroModel ): start_location : Location finish_location : typing . List [ Location ] class Meta : schema_doc = False Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"namespace\" : \"types.location_type\" } }, { \"name\" : \"finish_location\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"types.location_type.Location\" , \"name\" : \"finish_location\" } } ] } ' class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" schema_doc = False class Trip ( AvroModel ): start_location : Location finish_location : typing . Dict [ str , Location ] class Meta : schema_doc = False Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"namespace\" : \"types.location_type\" } }, { \"name\" : \"finish_location\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"types.location_type.Location\" , \"name\" : \"finish_location\" } } ] } ' (This script is complete, it should run \"as is\") If you want, also you can use custom name for nested items ( nested records , arrays or maps ) using the property alias_nested_items in class Meta : from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address # default name Address class Meta : alias_nested_items = { \"address\" : \"MySuperAddress\" } User.avro_schema() will generate: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"MySuperAddress\" , // renamed it using alias_nested_items \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } (This script is complete, it should run \"as is\")","title":"Schema Relationships"},{"location":"schema_relationships/#schema-relationships","text":"","title":"Schema Relationships"},{"location":"schema_relationships/#onetoone","text":"An User has one Address example from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } ' (This script is complete, it should run \"as is\")","title":"OneToOne"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","text":"An User with only one friend :-( import typing from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friend\" , \"type\" : [ \"null\" , \"User\" ], \"default\" : null } ], \"doc\" : \"User with self reference as friend\" } ' (This script is complete, it should run \"as is\")","title":"OneToOne Recursive Schema Relationship"},{"location":"schema_relationships/#onetomany-schema-relationship","text":"An User has multiple Address example import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' (This script is complete, it should run \"as is\") OneToMany with Map example import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' (This script is complete, it should run \"as is\")","title":"OneToMany Schema Relationship"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","text":"OneToMany recursive example import typing from dataclasses_avroschema import AvroModel # Using a List (Avro Array) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" }, \"default\" : [] } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" }, \"default\" : {} } ], \"doc\" : \"User with self reference as friends\" } ' (This script is complete, it should run \"as is\")","title":"OneToMany Recursive Schema Relationship"},{"location":"schema_relationships/#avoid-name-collision-in-multiple-relationships","text":"Sometimes we have relationships where a class is related more than once with a particular class, and the name for the nested schemas must be different, otherwise we will generate an invalid avro schema . For those cases, you MUST define the namespace . Avoiding name collision example from dataclasses import dataclass from datetime import datetime import json from dataclasses_avroschema import AvroModel @dataclass class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" @dataclass class Trip ( AvroModel ): start_time : datetime start_location : Location # first relationship finish_time : datetime finish_location : Location # second relationship Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"doc\" : \"Location(latitude: float, longitude: float)\" , \"namespace\" : \"types.location_type\" }}, { \"name\" : \"finish_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"finish_location\" , \"type\" : \"types.location_type.Location\" // using the namespace } ], \"doc\" : \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\" } (This script is complete, it should run \"as is\") or with arrays or maps : class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" schema_doc = False class Trip ( AvroModel ): start_location : Location finish_location : typing . List [ Location ] class Meta : schema_doc = False Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"namespace\" : \"types.location_type\" } }, { \"name\" : \"finish_location\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"types.location_type.Location\" , \"name\" : \"finish_location\" } } ] } ' class Location ( AvroModel ): latitude : float longitude : float class Meta : namespace = \"types.location_type\" schema_doc = False class Trip ( AvroModel ): start_location : Location finish_location : typing . Dict [ str , Location ] class Meta : schema_doc = False Trip . avro_schema () { \"type\" : \"record\" , \"name\" : \"Trip\" , \"fields\" : [ { \"name\" : \"start_location\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Location\" , \"fields\" : [ { \"name\" : \"latitude\" , \"type\" : \"double\" }, { \"name\" : \"longitude\" , \"type\" : \"double\" } ], \"namespace\" : \"types.location_type\" } }, { \"name\" : \"finish_location\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"types.location_type.Location\" , \"name\" : \"finish_location\" } } ] } ' (This script is complete, it should run \"as is\") If you want, also you can use custom name for nested items ( nested records , arrays or maps ) using the property alias_nested_items in class Meta : from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address # default name Address class Meta : alias_nested_items = { \"address\" : \"MySuperAddress\" } User.avro_schema() will generate: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"long\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"MySuperAddress\" , // renamed it using alias_nested_items \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"long\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } (This script is complete, it should run \"as is\")","title":"Avoid name collision in multiple relationships"},{"location":"serialization/","text":"Is possible to serialize/deserialize with the correspondent avro schema generated and the dataclass. In both cases we can do it with avro or avro-json . Serialization For serialization is neccesary to use python class/dataclasses instance: Avro and avro-json serialization from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] address_data = { \"street\" : \"test\" , \"street_number\" : 10 , } # create an Address instance address = Address ( ** address_data ) data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [ address ], } # create an User instance user = User ( ** data_user ) user . serialize () # >>> b\"\\x08john(\\x02\\x08test\\x14\\x00\" user . serialize ( serialization_type = \"avro-json\" ) # >>> b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' user . to_json () # python dict >>> {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]} (This script is complete, it should run \"as is\") Deserialization Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance. Avro and avro-json deserialization import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] avro_binary = b \" \\x08 john( \\x02\\x08 test \\x14\\x00 \" avro_json_binary = b '{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' # return a new class instance!! User . deserialize ( avro_binary ) # >>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_binary , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} # return a new class instance!! User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" ) # >>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} (This script is complete, it should run \"as is\") Deserialization of records encoded via a different schema To deserialize data encoded via a different schema, one can pass an optional writer_schema: AvroModel | dict[str, Any] attribute. It will be used by the fastavro s schemaless_reader . Deserialization with different schemas @dataclass class User ( AvroModel ): name : str age : int @dataclass class UserCompatible ( AvroModel ): name : str age : int nickname : Optional [ str ] = None class Meta : schema_name = \"User\" user_data = { \"name\" : \"G.R. Emlin\" , \"age\" : 52 , } # serialize data with the User schema >>> serialized_user = User ( ** user_data ) . serialize () # deserialize user using a new, but compatible schema >>> deserialized_user = UserCompatible . deserialize ( serialized_user , writer_schema = User ) (This script is complete, it should run \"as is\") Custom Serialization The serialization/deserialization process is built over fastavro . If you want to use another library or a different process, you can override the base AvroModel : Custom serialization from dataclasses_avroschema import AvroModel class MyAvroModel ( AvroModel ): ... def serialize ( self , serialization_type : str = AVRO ) -> bytes : # Get the schema as a python dict schema = self . avro_schema_to_python () # instance as python dict data = self . asdict () # call your custom serialization withe the avro schema and the data return custom_serialization ( schema , datam serialization_type = serialization_type ) @classmethod def deserialize ( cls , data : bytes , serialization_type : str = AVRO , create_instance : bool = True ) -> typing . Union [ typing . Dict , \"AvroModel\" ]: # Get the schema as a python dict schema = cls . avro_schema_to_python () # get the python dict with the schema and the data (bytes) payload = custom_deserialize ( data , schema , serialization_type = serialization_type ) if create_instance : return from_dict ( data_class = cls , data = payload , config = Config ( check_types = False )) return payload # and then inherits from your custom AvroModel class Address ( MyAvroModel ): \"An Address\" street : str street_number : int Encoding for unions with avro-json When you have an union and you want to serialize a payload using avro-json you will notice that the type is added to each union field. This is needed because after the serialization process you need to know the type in order to deserialize : Do not confuse json with avro-json!! Union encoding with avro-json example import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel @dataclasses . dataclass class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] my_union = UnionSchema ( first_union = 10 , logical_union = datetime . datetime . now ()) event = my_union . serialize ( serialization_type = \"avro-json\" ) print ( event ) # long is added to each field >>> b '{\"first_union\": {\"long\": 10}, \"logical_union\": {\"long\": 1647971584847}}' my_union . deserialize ( event , serialization_type = \"avro-json\" ) # >>> UnionSchema(first_union=10, logical_union=datetime.datetime(2022, 3, 22, 17, 53, 4, 847000, tzinfo=datetime.timezone.utc)) # bad data event_2 = b '{\"first_union\": 10, \"logical_union\": {\"long\": 1647971584847}}' my_union . deserialize ( event_2 , serialization_type = \"avro-json\" ) File ~/ Projects / dataclasses - avroschema /. venv / lib / python3 .8 / site - packages / fastavro / io / json_decoder . py : 213 , in AvroJSONDecoder . read_index ( self ) 211 label = \"null\" 212 else : --> 213 label , data = self . _current [ self . _key ] . popitem () 214 self . _current [ self . _key ] = data 215 # TODO: Do we need to do this? AttributeError : 'int' object has no attribute 'popitem' (This script is complete, it should run \"as is\")","title":"Serialization"},{"location":"serialization/#serialization","text":"For serialization is neccesary to use python class/dataclasses instance: Avro and avro-json serialization from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] address_data = { \"street\" : \"test\" , \"street_number\" : 10 , } # create an Address instance address = Address ( ** address_data ) data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [ address ], } # create an User instance user = User ( ** data_user ) user . serialize () # >>> b\"\\x08john(\\x02\\x08test\\x14\\x00\" user . serialize ( serialization_type = \"avro-json\" ) # >>> b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' user . to_json () # python dict >>> {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]} (This script is complete, it should run \"as is\")","title":"Serialization"},{"location":"serialization/#deserialization","text":"Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance. Avro and avro-json deserialization import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] avro_binary = b \" \\x08 john( \\x02\\x08 test \\x14\\x00 \" avro_json_binary = b '{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' # return a new class instance!! User . deserialize ( avro_binary ) # >>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_binary , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} # return a new class instance!! User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" ) # >>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} (This script is complete, it should run \"as is\")","title":"Deserialization"},{"location":"serialization/#deserialization-of-records-encoded-via-a-different-schema","text":"To deserialize data encoded via a different schema, one can pass an optional writer_schema: AvroModel | dict[str, Any] attribute. It will be used by the fastavro s schemaless_reader . Deserialization with different schemas @dataclass class User ( AvroModel ): name : str age : int @dataclass class UserCompatible ( AvroModel ): name : str age : int nickname : Optional [ str ] = None class Meta : schema_name = \"User\" user_data = { \"name\" : \"G.R. Emlin\" , \"age\" : 52 , } # serialize data with the User schema >>> serialized_user = User ( ** user_data ) . serialize () # deserialize user using a new, but compatible schema >>> deserialized_user = UserCompatible . deserialize ( serialized_user , writer_schema = User ) (This script is complete, it should run \"as is\")","title":"Deserialization of records encoded via a different schema"},{"location":"serialization/#custom-serialization","text":"The serialization/deserialization process is built over fastavro . If you want to use another library or a different process, you can override the base AvroModel : Custom serialization from dataclasses_avroschema import AvroModel class MyAvroModel ( AvroModel ): ... def serialize ( self , serialization_type : str = AVRO ) -> bytes : # Get the schema as a python dict schema = self . avro_schema_to_python () # instance as python dict data = self . asdict () # call your custom serialization withe the avro schema and the data return custom_serialization ( schema , datam serialization_type = serialization_type ) @classmethod def deserialize ( cls , data : bytes , serialization_type : str = AVRO , create_instance : bool = True ) -> typing . Union [ typing . Dict , \"AvroModel\" ]: # Get the schema as a python dict schema = cls . avro_schema_to_python () # get the python dict with the schema and the data (bytes) payload = custom_deserialize ( data , schema , serialization_type = serialization_type ) if create_instance : return from_dict ( data_class = cls , data = payload , config = Config ( check_types = False )) return payload # and then inherits from your custom AvroModel class Address ( MyAvroModel ): \"An Address\" street : str street_number : int","title":"Custom Serialization"},{"location":"serialization/#encoding-for-unions-with-avro-json","text":"When you have an union and you want to serialize a payload using avro-json you will notice that the type is added to each union field. This is needed because after the serialization process you need to know the type in order to deserialize : Do not confuse json with avro-json!! Union encoding with avro-json example import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel @dataclasses . dataclass class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] my_union = UnionSchema ( first_union = 10 , logical_union = datetime . datetime . now ()) event = my_union . serialize ( serialization_type = \"avro-json\" ) print ( event ) # long is added to each field >>> b '{\"first_union\": {\"long\": 10}, \"logical_union\": {\"long\": 1647971584847}}' my_union . deserialize ( event , serialization_type = \"avro-json\" ) # >>> UnionSchema(first_union=10, logical_union=datetime.datetime(2022, 3, 22, 17, 53, 4, 847000, tzinfo=datetime.timezone.utc)) # bad data event_2 = b '{\"first_union\": 10, \"logical_union\": {\"long\": 1647971584847}}' my_union . deserialize ( event_2 , serialization_type = \"avro-json\" ) File ~/ Projects / dataclasses - avroschema /. venv / lib / python3 .8 / site - packages / fastavro / io / json_decoder . py : 213 , in AvroJSONDecoder . read_index ( self ) 211 label = \"null\" 212 else : --> 213 label , data = self . _current [ self . _key ] . popitem () 214 self . _current [ self . _key ] = data 215 # TODO: Do we need to do this? AttributeError : 'int' object has no attribute 'popitem' (This script is complete, it should run \"as is\")","title":"Encoding for unions with avro-json"}]}